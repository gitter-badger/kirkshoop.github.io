---
layout: post
title: a scratch program
date: '2011-11-10T10:00:00.000-08:00'
author: Kirk
tags:
- win32
- programming
modified_time: '2011-11-10T10:00:00.308-08:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-3252825964311789317
blogger_orig_url: http://kirkshoop.blogspot.com/2011/11/scratch-program.html
---

<p>I have been working on a library for building win32 windows. MFC and WTL were both great designs at the time that they were introduced, but C++ has moved on. Then there is Raymond Chen's new(2005) C++ scratch program which eschews libraries and builds a simple base class with virtual functions</p><p>One of the things that bothers me about all the existing libraries is that they mix two distinct objects with separate lifetimes into one object with incoherent lifetime. I will go into more detail on this and other design decisions in additional posts. </p><p>So here is a port of Raymond's scratch program using my window library. </p><pre class="prettyprint lang-cpp"><br />#define STRICT<br />#define WIN32_LEAN_AND_MEAN<br />#define NOMINMAX<br />#define UNICODE<br />#define _UNICODE<br /><br />#include &lt;windows.h&gt;<br />#include &lt;windowsx.h&gt;<br />#include &lt;ole2.h&gt;<br />#include &lt;commctrl.h&gt;<br />#include &lt;shlwapi.h&gt;<br />#include &lt;shlobj.h&gt;<br />#include &lt;shellapi.h&gt;<br /><br />#include &lt;new&gt;<br />#include &lt;utility&gt;<br />#include &lt;memory&gt;<br />#include &lt;type_traits&gt;<br />#include &lt;tuple&gt;<br />#include &lt;string&gt;<br />#include &lt;vector&gt;<br /><br />#define LIBRARIES_NAMESPACE mylib<br />#include "..\libraries\libraries.h"<br />namespace l = LIBRARIES_NAMESPACE;<br /><br />void unique_error_report_initiated(<br />  DWORD value,<br />  unique_winerror::tag &amp;&amp;)<br />{<br />  static DWORD anchor;<br />  anchor = value;<br />}<br /><br />void unique_error_report_reset(<br />  DWORD value,<br />  unique_winerror::tag &amp;&amp;)<br />{<br />  static DWORD anchor;<br />  anchor = value;<br />}<br /><br />void unique_error_report_initiated(<br />  HRESULT value,<br />  unique_hresult::tag &amp;&amp;)<br />{<br />  static HRESULT anchor;<br />  anchor = value;<br />}<br /><br />void unique_error_report_reset(<br />  HRESULT value,<br />  unique_hresult::tag &amp;&amp;)<br />{<br />  static HRESULT anchor;<br />  anchor = value;<br />}<br /><br />namespace RootWindow {<br />struct tag {};<br /><br />typedef<br />  l::wnd::Context&lt;tag&gt;<br />    Context;<br /><br />struct window<br />{<br />  l::wr::unique_close_window child;<br /><br />  LRESULT OnCreate(const Context&amp; , LPCREATESTRUCT) {<br />    return 0;<br />  }<br /><br />  LRESULT OnSize(const Context&amp; , UINT , int cx, int cy) {<br />    if (child) {<br />      SetWindowPos(<br />        child.get(), NULL,<br />        0, 0, cx, cy,<br />        SWP_NOZORDER | SWP_NOACTIVATE);<br />    }<br />    return 0;<br />  }<br /><br />  LRESULT PaintContent(PAINTSTRUCT&amp;) {<br />    return 0;<br />  }<br /><br />  LRESULT OnPaint(const Context&amp; context) {<br />    PAINTSTRUCT ps = {};<br />    BeginPaint(context.window, &amp;ps);<br />    l::wr::unique_gdi_end_paint ender(<br />      std::make_pair(context.window, &amp;ps));<br />    return PaintContent(ps);<br />  }<br /><br />  LRESULT OnPrintClient(const Context&amp; context, HDC hdc, DWORD) {<br />    PAINTSTRUCT ps = {};<br />    ps.hdc = hdc;<br />    GetClientRect(context.window, &amp;ps.rcPaint);<br />    return PaintContent(ps);<br />  }<br /><br />  LRESULT OnNCDestroy(const Context&amp;) {<br />    PostQuitMessage(0);<br />    return 0;<br />  }<br />};<br /><br />l::wnd::window_class_traits_builder&lt;window&gt;<br />window_class_traits(tag &amp;&amp;);<br /><br />void window_class_register(<br />  PCWSTR windowClass,<br />  WNDCLASSEX* wcex,<br />  tag &amp;&amp;) {<br />  wcex-&gt;style         = 0;<br />  wcex-&gt;hIcon         = NULL;<br />  wcex-&gt;hCursor       = LoadCursor(NULL, IDC_ARROW);<br />  wcex-&gt;lpszMenuName  = NULL;<br />  wcex-&gt;lpszClassName = windowClass;<br />}<br />}<br /><br />template&lt;typename Function, typename MessageTag&gt;<br />void window_message_error_contract(<br />  Function &amp;&amp; function,<br />  RootWindow::Context&amp; ,<br />  MessageTag &amp;&amp; ,<br />  RootWindow::tag &amp;&amp;)<br />{<br />  try {<br />    std::forward&lt;Function&gt;(function)();<br />  } catch (std::bad_alloc &amp;&amp;) {<br />  } catch (unique_winerror::exception &amp;&amp;) {<br />  } catch (unique_hresult::exception &amp;&amp;) {<br />  }<br />}<br /><br />typedef<br />  l::wnd::window_class&lt;RootWindow::tag&gt;<br />    RootWindowClass;<br /><br />int PASCAL<br />wWinMain(HINSTANCE hinst, HINSTANCE, LPWSTR, int nShowCmd)<br />{<br />  unique_hresult hr;<br /><br />  hr.reset(CoInitialize(NULL));<br />  if (!hr) {<br />    return FALSE;<br />  }<br />  ON_UNWIND_AUTO([&amp;] {CoUninitialize();});<br /><br />  InitCommonControls();<br /><br />  RootWindowClass::Register(L"Scratch");<br /><br />  unique_winerror winerror;<br />  l::wr::unique_close_window window;<br /><br />  std::tie(winerror, window) =<br />    l::wr::winerror_and_close_window(<br />        CreateWindow(<br />            L"Scratch", L"Scratch",<br />            WS_OVERLAPPEDWINDOW,<br />            CW_USEDEFAULT, CW_USEDEFAULT,<br />            CW_USEDEFAULT, CW_USEDEFAULT,<br />            NULL, NULL,<br />            hinst,<br />            NULL));<br /><br />  if (!winerror || !window) {<br />    return winerror.get();<br />  }<br /><br />  ShowWindow(window.get(), nShowCmd);<br /><br />  MSG msg = {};<br />  while (GetMessage(&amp;msg, NULL, 0, 0)) {<br />    TranslateMessage(&amp;msg);<br />    DispatchMessage(&amp;msg);<br />  }<br />  return 0;<br />}<br /></pre>