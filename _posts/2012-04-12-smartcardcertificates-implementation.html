---
layout: post
title: smartcard_certificates implementation
date: '2012-04-12T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- smart card
- programming
modified_time: '2012-04-12T10:00:02.059-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-7666175139696706287
blogger_orig_url: http://kirkshoop.blogspot.com/2012/04/smartcardcertificates-implementation.html
---

<p>Given a provider name <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'NCryptEnumKeys'%29"><code class="prettyprint lang-cpp">NCryptEnumKeys</code></a> can be used to retrieve all the keys known to that provider. Since the KSP provider is shared across all cards associated to it, the keys from all associated cards will be returned.  </p><p>Here is a function that uses <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'NCryptEnumKeys'%29"><code class="prettyprint lang-cpp">NCryptEnumKeys</code></a> and <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'NCryptGetProperty'%29"><code class="prettyprint lang-cpp">NCryptGetProperty</code></a> to retrieve the keys and certificates from a KSP provider name. </p><pre class="prettyprint lang-cpp"><br />struct KeyWithCertificate {<br />  std::wstring key;<br />  std::vector&lt;BYTE&gt; cert;<br />};<br />typedef<br />  std::vector&lt;KeyWithCertificate&gt;<br />KeyWithCertificateVector;<br /><br />inline<br />std::pair&lt;unique_winerror, KeyWithCertificateVector&gt;<br />smartcard_certificates(<br />  const std::wstring&amp; kspstring<br />)<br />{<br />  unique_winerror winerror;<br />  KeyWithCertificateVector output;<br /><br />  NCRYPT_PROV_HANDLE provider = NULL;<br />  ON_UNWIND_AUTO(<br />    [&amp;] { <br />      if (provider) {<br />        NCryptFreeObject(provider);<br />      }<br />    }<br />  );<br />  winerror.reset(<br />    NCryptOpenStorageProvider(<br />        &amp;provider,<br />        kspstring.c_str(),<br />        0<br />    )<br />  );<br />  if (!winerror) {<br />    return std::make_pair(winerror, std::move(output));<br />  }<br /><br />  NCryptKeyName* keyname = nullptr;<br />  ON_UNWIND_AUTO(<br />    [&amp;] { <br />      if (keyname) {<br />        NCryptFreeBuffer(keyname);<br />      }<br />    }<br />  );<br />  void* enumstate = nullptr;<br />  ON_UNWIND_AUTO(<br />    [&amp;] { <br />      if (enumstate) {<br />        NCryptFreeBuffer(enumstate);<br />      }<br />    }<br />  );<br />  for (;;) {<br />    winerror.reset(<br />      NCryptEnumKeys(<br />          provider,<br />          NULL,<br />          &amp;keyname,<br />          &amp;enumstate,<br />          NCRYPT_SILENT_FLAG<br />      )<br />    );<br />    if (winerror == winerror_cast(NTE_NO_MORE_ITEMS)) {<br />      winerror.suppress().release();<br />      break;<br />    }<br />    if (!winerror) {<br />      return std::make_pair(winerror, std::move(output));<br />    }<br /><br />    KeyWithCertificate keystate;<br />    keystate.key = keyname-&gt;pszName;<br /><br />    NCRYPT_KEY_HANDLE key = NULL;<br />    ON_UNWIND_AUTO(<br />      [&amp;] { <br />        if (key) {<br />          NCryptFreeObject(key);<br />        }<br />      }<br />    );<br />    winerror.reset(<br />      NCryptOpenKey(<br />          provider,<br />          &amp;key,<br />          keyname-&gt;pszName,<br />          keyname-&gt;dwLegacyKeySpec,<br />          NCRYPT_SILENT_FLAG<br />      )<br />    );<br />    if (!winerror) {<br />      return std::make_pair(winerror, std::move(output));<br />    }<br /><br />    DWORD sizecert = 0;<br />    for (bool getsize = true; ; getsize = false) {<br />      winerror.reset(<br />        NCryptGetProperty(<br />            key,<br />            NCRYPT_CERTIFICATE_PROPERTY,<br />            getsize ? nullptr : &amp;keystate.cert[0],<br />            sizecert,<br />            &amp;sizecert,<br />            0<br />        )<br />      );<br />      if (!winerror) {<br />        return std::make_pair(winerror, std::move(output));<br />      }<br />      if (getsize) {<br />        keystate.cert.resize(sizecert);<br />      } else {<br />        break;<br />      }<br />    }<br /><br />    output.push_back(keystate);<br />  }<br /><br />  return std::make_pair(winerror, std::move(output));<br />}<br /></pre>