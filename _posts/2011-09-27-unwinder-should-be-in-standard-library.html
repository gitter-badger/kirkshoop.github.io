---
layout: post
title: an unwinder should be in the standard library
date: '2011-09-27T10:00:00.000-07:00'
author: Kirk
tags:
- programming
modified_time: '2011-09-27T10:00:00.534-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-3789495605458973972
blogger_orig_url: http://kirkshoop.blogspot.com/2011/09/unwinder-should-be-in-standard-library.html
---

<p>The Unwinder is an implementation of the <a href="http://drdobbs.com/cpp/184403758">ScopeGuard</a> pattern. The Unwinder is a class with a constructor that accepts a function and then runs that function in its destructor. The class has a method to dismiss the Unwinder. A dismissed unwinder will not run the function in its destructor. The Unwinder can be used as a generic implementation of the RRID (Resource Release Is Destruction) pattern. </p><p>With the addition of lambdas, auto and declspec to the C++ language the Unwinder becomes so trivial to use that in many cases no RAII class should be written. The implementation I use is called Unwinder. </p><p><h3>Unwinder usage</h3></p><pre class="prettyprint lang-cpp"><br />int main()<br />{<br />  CRITICAL_SECTION lock = {};<br />  if (<br />    !InitializeCriticalSectionAndSpinCount(<br />        &amp;lock,<br />        0x00000400)) {<br />    terminate();<br />  }<br /><br />  ON_UNWIND_AUTO([&amp;] {DeleteCriticalSection(&amp;lock);});<br /><br />  EnterCriticalSection(&amp;lock);<br />  ON_UNWIND_AUTO([&amp;] {LeaveCriticalSection(&amp;lock);});<br /><br />  // protected region<br /><br />  {<br />    LeaveCriticalSection(&amp;lock);<br />    ON_UNWIND_AUTO([&amp;] {EnterCriticalSection(&amp;lock);});<br /><br />    // unprotected region<br />  }<br /><br />  // protected region<br /><br />  return 0;<br />}<br /></pre><p><h3>Comparisons</h3><br />This actually intersects with discussions of code style. There are many ways to structure function implementations. Of those there are a few common patterns that produce predictable results. Here are two structures; goto-cleanup and nested-scope: </p><pre class="prettyprint lang-cpp"><br />int main()<br />{<br />  //<br />  // The goto-cleanup structure<br />  //<br /><br />  CRITICAL_SECTION lock = {};<br />  BOOL inLock = FALSE;<br /><br />  if (<br />    !InitializeCriticalSectionAndSpinCount(<br />        &amp;lock,<br />        0x00000400)) {<br />    terminate();<br />  }<br /><br />  EnterCriticalSection(&amp;lock);<br />  inLock = TRUE;<br /><br />  // protected region<br /><br />  LeaveCriticalSection(&amp;lock);<br />  inLock = FALSE;<br /><br />  // unprotected region<br /><br />  EnterCriticalSection(&amp;lock);<br />  inLock = TRUE;<br /><br />  // protected region<br /><br />Cleanup:<br />  if (inLock) {<br />    LeaveCriticalSection(&amp;lock);<br />    inLock = FALSE;<br />  }<br />  DeleteCriticalSection(&amp;lock);<br />  return 0;<br />}<br /></pre><pre class="prettyprint lang-cpp"><br />int main()<br />{<br />  //<br />  // The nested-scope structure<br />  //<br /><br />  CRITICAL_SECTION lock = {};<br /><br />  if (<br />    !!InitializeCriticalSectionAndSpinCount(<br />        &amp;lock,<br />        0x00000400)) {<br />    {<br />      EnterCriticalSection(&amp;lock);<br /><br />      // protected region<br /><br />      {<br />        LeaveCriticalSection(&amp;lock);<br /><br />        // unprotected region<br /><br />        EnterCriticalSection(&amp;lock);<br />      }<br /><br />      // protected region<br /><br />      LeaveCriticalSection(&amp;lock);<br />    }<br /><br />    DeleteCriticalSection(&amp;lock);<br />  }<br /><br />  return 0;<br />}<br /></pre><p>In both of these structures the code to undo or release an action is located a great distance from the action. Thus to read or verify the code one must scroll back and forth, even in short functions one must bounce visually all over the code to understand it.<br />Also, both of these are exception phobic. They require that exceptions are not used in the code.<br />Using the Unwinder, one is able to read left->right, top->bottom with no need to bounce. Each action is immediately followed by the undo. Even better, the code becomes exception agnostic, it will behave correctly with or without exceptions. </p><p><h3>Implementation</h3><br />The Unwinder is so subtle to build that it really should be in the standard. I have been through at least 4 implementations to reach my current one. One of the previous implementations was contributed by a coworker. His was based on std::function and did not require a macro to use correctly. After using it in my code for a while I pointed out that std::function could throw on construction and that this required changes to the implementation and made usage very tricky. After a year of periodic reviews of and changes to that implementation we finally decided to deprecate it, it was just too subtle and risky. The implementation included here does require macros, but is exception agnostic. This implementation is maintained <a href="https://github.com/kirkshoop/libraries">here</a>. </p><pre class="prettyprint lang-cpp"><br />//<br />// common tools<br />//<br /><br />#define MAKE_IDENTIFIER_EXPLICIT_PASTER(Prefix, Suffix) \<br />  Prefix ## Suffix<br /><br />#define MAKE_IDENTIFIER_EXPLICIT(Prefix, Suffix) \<br />  MAKE_IDENTIFIER_EXPLICIT_PASTER(Prefix, Suffix)<br /><br />#define MAKE_IDENTIFIER(Prefix) \<br />  MAKE_IDENTIFIER_EXPLICIT(Prefix, __LINE__)<br /><br />#define FAIL_FAST_FILTER() \<br />  __except(FailFastFilter(GetExceptionInformation())) \<br />  { \<br />  } do {} while(0,0)<br /><br />inline<br />LONG WINAPI FailFastFilter(<br />  __in  struct _EXCEPTION_POINTERS* exceptionInfo)<br />{<br />  RaiseFailFastException(<br />    exceptionInfo-&gt;ExceptionRecord,<br />    exceptionInfo-&gt;ContextRecord,<br />    0);<br />  return EXCEPTION_CONTINUE_SEARCH;<br />}<br /><br />template&lt;typename Function&gt;<br />auto FailFastOnThrow(<br />  Function &amp;&amp; function) -&gt; decltype(<br />      std::forward&lt;Function&gt;(function)())<br />{<br />  //<br />  // __ try must be isolated in its own<br />  // function in order for the compiler<br />  // to reason about C++ unwind in the<br />  // calling and called functions.<br />  //<br />  __try {<br />    return std::forward&lt;Function&gt;(function)();<br />  }<br />  FAIL_FAST_FILTER();<br />}<br /><br />#define FAIL_FAST_ON_THROW(Function) \<br />  FailFastOnThrow((Function))<br /><br />//<br />// unwinder<br />//<br /><br />template&lt;typename Function&gt;<br />class unwinder<br />{<br />public:<br />  ~unwinder() {<br />    if (!!function) {<br />      FAIL_FAST_ON_THROW([&amp;] {(*function)();});<br />    }<br />  }<br /><br />  explicit unwinder(Function* functionArg)<br />    : function(functionArg) {<br />  }<br /><br />  void dismiss() {<br />    function = nullptr;<br />  }<br /><br />private:<br />  unwinder();<br />  unwinder(const unwinder&amp;);<br />  unwinder&amp; operator=(const unwinder&amp;);<br /><br />  Function* function;<br />};<br /><br />#define ON_UNWIND(Name, Function) \<br />  ON_UNWIND_EXPLICIT( \<br />      uwfunc_ ## Name, \<br />      Name, \<br />      Function)<br /><br />#define ON_UNWIND_AUTO(Function) \<br />  ON_UNWIND_EXPLICIT( \<br />      MAKE_IDENTIFIER(uwfunc_), \<br />      MAKE_IDENTIFIER(unwind_), \<br />      Function)<br /><br />#define ON_UNWIND_EXPLICIT(FunctionName, UnwinderName, Function) \<br />  auto FunctionName = (Function); \<br />  unwinder&lt;decltype(FunctionName)&gt; \<br />  UnwinderName(std::addressof(FunctionName))<br /></pre>