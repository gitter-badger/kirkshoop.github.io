---
layout: post
title: WindowCallback
date: '2011-11-29T10:00:00.000-08:00'
author: Kirk
tags:
- win32
- programming
modified_time: '2011-11-29T10:00:00.612-08:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-3105625845999126663
blogger_orig_url: http://kirkshoop.blogspot.com/2011/11/windowcallback.html
---

<p>Time for a look at <code class="prettyprint lang-cpp">WindowCallback</code> which implements a <code class="prettyprint lang-cpp">WNDPROC</code>. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename WindowClassTag&gt;<br />LRESULT CALLBACK WindowCallback(<br />  HWND hWnd,<br />  UINT message,<br />  WPARAM wParam,<br />  LPARAM lParam) {<br />  __try {<br />    return detail::WindowCallbackSafe&lt;WindowClassTag&gt;(<br />        hWnd,<br />        message,<br />        wParam,<br />        lParam);<br />  } __except (FailFastFilter(GetExceptionInformation())) {<br />  }<br />  return 0;<br />}<br /></pre><p>Not much here, just set up an SEH exception filter that will prevent any exceptions from passing across the boundary from this module to the calling module. </p><pre class="prettyprint lang-cpp"><br />namespace detail {<br /><br />template&lt;typename WindowClassTag&gt;<br />LRESULT CALLBACK WindowCallbackSafe(<br />  HWND hWnd,<br />  UINT message,<br />  WPARAM wParam,<br />  LPARAM lParam) {<br /><br />  bool handled = false;<br />  LRESULT result = 0;<br /><br />  if (message == WM_NCCREATE) {<br />    auto existingType = optional_window_class_find(<br />      hWnd,<br />      WindowClassTag(),<br />      0);<br />    if (!existingType) {<br />      if (!optional_window_class_insert(<br />        hWnd,<br />        optional_window_class_construct(<br />          hWnd,<br />          reinterpret_cast&lt;LPCREATESTRUCT&gt;(lParam),<br />          WindowClassTag(),<br />          0),<br />        WindowClassTag(),<br />        0)) {<br />        return FALSE;<br />      }<br />    }<br />  }<br /></pre><p><code class="prettyprint lang-cpp">window_class_find</code>, <code class="prettyprint lang-cpp">window_class_insert</code>, <code class="prettyprint lang-cpp">window_class_construct</code>, <code class="prettyprint lang-cpp">window_class_erase</code> and <code class="prettyprint lang-cpp">window_class_destroy</code> are used to manage the lifetime of the implementation. The optional_ prefix refers to functions that provide a default behavior when the implementation does not choose to provide overloads of the functions. The defaults use <code class="prettyprint lang-cpp">new</code> and <code class="prettyprint lang-cpp">delete</code> for allocation and <code class="prettyprint lang-cpp">SetWindowLongPtr</code> to store and retrieve the implementation. Each implementation can provide overloads of these functions to control allocation, construction and storage of that implementation. </p><p>This code will create and store the implementation in response to <code class="prettyprint lang-cpp">WM_NCCREATE</code>. The attempt to find is here to guard against multiple <code class="prettyprint lang-cpp">WM_NCCREATE</code> messages. </p><pre class="prettyprint lang-cpp"><br />  auto type = optional_window_class_find(hWnd, WindowClassTag(), 0);<br /><br />  ON_UNWIND_AUTO(<br />  [&amp;] {<br />    if (type &amp;&amp; message == WM_NCDESTROY) {<br />      optional_window_class_erase(hWnd, type, WindowClassTag(), 0);<br />      optional_window_class_destroy(hWnd, type, WindowClassTag(), 0);<br />    }<br />  }<br />  );<br /></pre><p>Here the code attempts to retrieve the implementation and setup a lambda function to destroy the implementation when <code class="prettyprint lang-cpp">WindowCallback</code> exits. Using <code class="prettyprint lang-cpp">ON_UNWIND</code> means that even a C++ exception will run the lambda. </p><pre class="prettyprint lang-cpp"><br />  if (type) {<br />    Context&lt;WindowClassTag&gt; context = {hWnd, message, wParam, lParam};<br /><br />    std::tie(handled, result) = msg::dispatch(type, context);<br />    if (handled) {<br />      return result;<br />    }<br />  }<br /><br />  return DefWindowProc(hWnd, message, wParam, lParam);<br />}<br />}<br /></pre><p>The rest just calls the dispatch mechanism to forward the message to the correct function on the implementation - if it exists - and calls DefWindowProc otherwise. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename WindowClassTag&gt;<br />decltype(<br />  window_class_find(<br />    cmn::instance_of&lt;HWND&gt;::value,<br />    WindowClassTag()))<br />optional_window_class_find(HWND hwnd, WindowClassTag &amp;&amp; , int)<br />{<br />  return window_class_find(hwnd, WindowClassTag());<br />}<br /><br />template&lt;typename WindowClassTag&gt;<br />typename window_class&lt;WindowClassTag&gt;::traits::type*<br />optional_window_class_find(HWND hwnd, WindowClassTag &amp;&amp; , ...)<br />{<br />  typedef<br />    typename window_class&lt;WindowClassTag&gt;::traits::type<br />  type;<br />  return reinterpret_cast&lt;type*&gt;(<br />    GetWindowLongPtr(hwnd, GWLP_USERDATA));<br />}<br /></pre><p>Using <code class="prettyprint lang-cpp">optional_window_class_find</code> as an example of the optional_ pattern. The two functions both take the same parameters up until the last one. The last one is used so that when both functions are included in the overload set the compiler can break the tie. The compiler will choose to send 0 literal to an int parameter rather than ... but if the overload set only contains the function with the last parameter ends in ... then the compiler will select it without an error. </p><p>In this case the first function takes precedence only if the decltype can find a <code class="prettyprint lang-cpp">windows_class_find</code> overload that takes these parameters. If it cannot the second function will be used to provide default functionality. </p><p>Next we will look at the magical msg dispatcher.. </p>