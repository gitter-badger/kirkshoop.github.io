---
layout: post
title: walk-through of RootWindow from scratch program
date: '2011-11-15T10:00:00.000-08:00'
author: Kirk
tags:
- win32
- programming
modified_time: '2011-11-15T10:00:07.346-08:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-9001144771348903966
blogger_orig_url: http://kirkshoop.blogspot.com/2011/11/walk-through-of-rootwindow-from-scratch.html
---

<p>Last time I posted a port of Raymond Chen's <a href="http://blogs.msdn.com/b/oldnewthing/archive/2005/04/22/410773.aspx"></a>scratch program. I mentioned that I had some goals for the design of the window library. One of those goals was to follow the intended window lifetime model. Most of the controls built into windows work by registering window classes that will allocate memory to store their state on the first message (usually <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms632635(v=vs.85).aspx">WM_NCCREATE</a>) and deallocate that state on the last message (usually <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms632636(v=VS.85).aspx">WM_NCDESTROY</a>). The window handle returned from CreateWindow is then used to send messages to get or set state. </p><p>In most existing libraries there is a single class with both the window handle and the state and an instance of the class is allocated and then passed to CreateWindow. Deallocation becomes challenging. If it is deallocated on <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms632636(v=VS.85).aspx">WM_NCDESTROY</a> then there is a risk that the object will be accessed after the destructor has run. In addition there is always the risk that delete could be called while the window is still trying to send messages. </p><p>Following the pattern used by the built-in controls results in a much safer lifetime model. </p><p>The following walkthrough will explain how each line contributes to the pattern: </p><p>Add a namespace where the implementation details of the window can be placed </p><pre class="prettyprint lang-cpp"><br />namespace RootWindow {<br /></pre><p>This struct tag is the glue that is used to leverage ADL to stitch all the pieces of the window together. </p><pre class="prettyprint lang-cpp"><br />struct tag {};<br /></pre><p>Adding a typedef for the Context just reduces typing. Notice the tag is used to make this Context unique to RootWindow. </p><pre class="prettyprint lang-cpp"><br />typedef<br />  l::wnd::Context&lt;tag&gt;<br />    Context;<br /></pre><p>The struct window is allocated by the library on <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms632635(v=vs.85).aspx">WM_NCCREATE</a> to provide the runtime state for the window. in addition to the state it also provides a function for each window message it wishes to receive<br />The child member is there to mirror Raymond's scratch program as is the empty OnCreate.<br />OnPaint and OnPrintClient are in the base class of Raymond's scratch and I could have placed them in a common location as well, but I have not settled on the best place for them so they are here for now. </p><p>Notice that there is no message map. The library uses templates to detect which methods exist on struct window and only handle those. The rest go to <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms633572(v=VS.85).aspx">DefWindowProc</a>. </p><pre class="prettyprint linenums lang-cpp"><br />struct window<br />{<br />  l::wr::unique_close_window child;<br /><br />  LRESULT OnCreate(const Context&amp; , LPCREATESTRUCT) {<br />    return 0;<br />  }<br /><br />  LRESULT OnSize(const Context&amp; , UINT , int cx, int cy) {<br />    if (child) {<br />      SetWindowPos(<br />        child.get(), NULL,<br />        0, 0, cx, cy,<br />        SWP_NOZORDER | SWP_NOACTIVATE);<br />    }<br />    return 0;<br />  }<br /><br />  LRESULT PaintContent(PAINTSTRUCT&amp;) {<br />    return 0;<br />  }<br /><br />  LRESULT OnPaint(const Context&amp; context) {<br />    PAINTSTRUCT ps = {};<br />    BeginPaint(context.window, &amp;ps);<br />    l::wr::unique_gdi_end_paint ender(<br />      std::make_pair(context.window, &amp;ps));<br />    return PaintContent(ps);<br />  }<br /><br />  LRESULT OnPrintClient(const Context&amp; context, HDC hdc, DWORD) {<br />    PAINTSTRUCT ps = {};<br />    ps.hdc = hdc;<br />    GetClientRect(context.window, &amp;ps.rcPaint);<br />    return PaintContent(ps);<br />  }<br /><br />  LRESULT OnNCDestroy(const Context&amp;) {<br />    PostQuitMessage(0);<br />    return 0;<br />  }<br />};<br /></pre><p>This declares a function that has no implementation. This function is used by the library to locate the window class using the tag struct. Since it is never called and is only referenced in a decltype expression there is no need for an implementation. </p><pre class="prettyprint lang-cpp"><br />l::wnd::window_class_traits_builder&lt;window&gt;<br />window_class_traits(tag &amp;&amp;);<br /></pre><p>This function does need an implementation. The library calls this function to allow the window registration defaults to be changed. The library uses the tag to find this function.  </p><pre class="prettyprint linenums lang-cpp"><br />void window_class_register(<br />  PCWSTR windowClass,<br />  WNDCLASSEX* wcex,<br />  tag &amp;&amp;) {<br />  wcex-&gt;style         = 0;<br />  wcex-&gt;hIcon         = NULL;<br />  wcex-&gt;hCursor       = LoadCursor(NULL, IDC_ARROW);<br />  wcex-&gt;lpszMenuName  = NULL;<br />  wcex-&gt;lpszClassName = windowClass;<br />}<br />}<br /></pre><p>This function is found using the tag as well. The library calls this function for each message that it dispatches. This function provides user-specified error handling. If this function does not catch exceptions the library will exit the process if an exception is thrown. This allows the library to be used in code that does not support exceptions as well (by skipping the try/catches). </p><pre class="prettyprint linenums lang-cpp"><br />template&lt;typename Function, typename MessageTag&gt;<br />void window_message_error_contract(<br />  Function &amp;&amp; function,<br />  RootWindow::Context&amp; ,<br />  MessageTag &amp;&amp; ,<br />  RootWindow::tag &amp;&amp;)<br />{<br />  try {<br />    std::forward&lt;Function&gt;(function)();<br />  } catch (std::bad_alloc &amp;&amp;) {<br />  } catch (unique_winerror::exception &amp;&amp;) {<br />  } catch (unique_hresult::exception &amp;&amp;) {<br />  }<br />}<br /></pre><p>This typedef actually stitches all the previous pieces into the final type. the window_class is given the tag after which it uses the tag to search out all the pieces and build a WndProc that will create a struct window and start calling OnCreate etc.. </p><pre class="prettyprint lang-cpp"><br />typedef<br />  l::wnd::window_class&lt;RootWindow::tag&gt;<br />    RootWindowClass;<br /></pre>