---
layout: post
title: unique_error
date: '2011-09-29T10:00:00.000-07:00'
author: Kirk
tags:
- error handling
- programming
modified_time: '2011-10-02T23:37:28.424-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-3753882413278545812
blogger_orig_url: http://kirkshoop.blogspot.com/2011/09/uniqueerror.html
---

<p>I work in places that abjure exceptions in most of the code. I have spent years writing both error-code and exception based error handling and building libraries for both environments. With some simple building blocks error-codes and exceptions can be joined such that each library can be written agnostic to exceptions and allow each caller of the library to choose whether to throw or pass error codes. These also implement certain exception features; such as requiring explicit checking of error codes. </p><p>One building block is unique_error. </p><p>unique_error serves much the same function as the <code class="prettyprint lang-cpp">std::system_error</code> but with additional features and eschewing some things that blocked my adoption of <code class="prettyprint lang-cpp">std::system_error</code>. unique_error does not require that all the error values of a type be redefined. It uses traits discovered by ADL to specify the behavior. It terminates the program if an error is set and then not checked. unique_error is also similar to unique_ptr in that it treats an error like a resource. </p><p>Here is the complete definition of unique_winerror: </p><pre class="prettyprint lang-cpp"><br />namespace unique_winerror_def<br />{<br />struct tag {};<br /><br />// found by ADL via the tag&amp;&amp; parameter<br />inline bool unique_error_ok(DWORD winerror, tag &amp;&amp;)<br />{<br />  return winerror == ERROR_SUCCESS;<br />}<br /><br />// found by ADL via the tag&amp;&amp; parameter<br />inline DWORD unique_error_default(tag &amp;&amp;)<br />{<br />  return ERROR_SUCCESS;<br />}<br />}<br /><br />//<br />// implementations of these must be included<br />// in the final module<br />//<br />void unique_error_report_initiated(<br />  DWORD value,<br />  unique_winerror_def::tag &amp;&amp;);<br />void unique_error_report_reset(<br />  DWORD value,<br />  unique_winerror_def::tag &amp;&amp;);<br /><br />typedef unique_error&lt;unique_winerror_def::tag&gt;<br />unique_winerror;<br /><br />inline unique_winerror make_winerror_if(BOOL is_last_error)<br />{<br />  unique_winerror result;<br />  if (is_last_error) {<br />    return std::move(result.reset(GetLastError()));<br />  }<br />  return std::move(result);<br />}<br /><br />inline<br />unique_winerror::static_error winerror_cast(DWORD raw)<br />{<br />  return unique_winerror::cast(raw);<br />}<br /></pre><p><h3>Using unique_winerror</h3></p><p><h4>CreateEvent example</h4>Starting from a previous post we can now improve the code further:  </p><pre class="prettyprint lang-cpp"><br />namespace Win32<br />{<br />template&lt;typename Resource, Resource InvalidValue&gt;<br />std::pair&lt;unique_winerror, Resource&gt;<br />WinerrorAndResource(Resource resource)<br />{<br />  return std::make_pair(<br />      make_winerror_if(Resource == InvalidValue),<br />      Resource);<br />}<br /><br />namespace Event<br />{<br />inline auto EventAndWinerror(<br />  HANDLE apiResult) -&gt; decltype(<br />      WinerrorAndResource&lt;HANDLE, nullptr&gt;(<br />          apiResult))<br />{<br />  return WinerrorAndResource&lt;HANDLE, nullptr&gt;(<br />      apiResult);<br />}<br />}<br />}<br /><br />// now you can write this<br />namespace we = Win32::Event;<br />unique_winerror winerror;<br />HANDLE event = nullptr;<br /><br />std::tie(<br />  winerror,<br />  event) = we::EventAndWinerror(<br />      CreateEvent(<br />          nullptr<br />          make(we::Reset::Manual),<br />          make(we::Value::Reset),<br />          nullptr));<br />if (!winerror)<br />{<br />  return;<br />}<br /></pre><p><h4>LoadString example</h4>The complexities of LoadString for arbitrary sized strings is encapsulated here: </p><pre class="prettyprint lang-cpp"><br />inline<br />unique_winerror<br />LoadStringRaw(<br />  HINSTANCE instance,<br />  UINT id,<br />  const range&lt;WCHAR*&gt;&amp; space,<br />  range&lt;WCHAR*&gt;* spaceUsed,<br />  size_t* spaceRequested)<br />{<br />  if (spaceUsed) {<br />    *spaceUsed = space;<br />    spaceUsed-&gt;advance_end(-space.size());<br />  }<br /><br />  if (spaceRequested) {<br />    *spaceRequested = space.size();<br />  }<br /><br />  SetLastError(ERROR_SUCCESS);<br /><br />  int loadResult = LoadStringW(<br />      instance,<br />      id,<br />      space.begin(),<br />      space.size());<br /><br />  auto winerror = make_winerror_if(TRUE);<br /><br />  if (loadResult &gt;= 0) {<br />    if ((loadResult + 1) &lt; space.size()) {<br />      if (winerror.ok()) {<br />        *spaceUsed = space;<br />        spaceUsed-&gt;advance_end(<br />          loadResult - space.size());<br />      }<br />    } else {<br />      *spaceRequested = std::max&lt;size_t&gt;(<br />          3,<br />          static_cast&lt;size_t&gt;(space.size() * 1.5));<br /><br />      if (winerror.ok()) {<br />        winerror = winerror_cast(ERROR_MORE_DATA);<br />      }<br />    }<br />  } else {<br />    if (winerror.ok()) {<br />      winerror = winerror_cast(ERROR_UNIDENTIFIED_ERROR);<br />    }<br />  }<br /><br />  return winerror;<br />}<br /><br />inline<br />std::wstring<br />LoadStdString(<br />  HINSTANCE instance,<br />  UINT id,<br />  size_t sizeLimit = 2048,<br />  size_t initialSize = 80)<br />{<br />  unique_winerror winerror;<br />  std::wstring result;<br />  RANGE_NAMESPACE::range&lt;WCHAR*&gt; spaceUsed;<br />  size_t spaceRequested = initialSize;<br /><br />  while (spaceRequested &lt; sizeLimit) {<br />    result.resize(spaceRequested);<br />    winerror = LoadStringRaw(<br />        instance,<br />        id,<br />        make_range_raw(result),<br />        &amp;spaceUsed,<br />        &amp;spaceRequested);<br />    if (winerror != winerror_cast(ERROR_MORE_DATA)) {<br />      winerror.throw_if();<br />      break;<br />    }<br />    winerror.suppress();<br />    continue;<br />  }<br /><br />  return std::move(result);<br />}<br /><br />std::wstring title;<br /><br />title = LoadStdString(<br />    hInstance,<br />    IDS_APP_TITLE);<br /></pre><p><h3>Implementation</h3>Maintained <a href="https://github.com/kirkshoop/libraries">here</a>. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename ErrorTag&gt;<br />class unique_error<br />{<br />public:<br />  typedef unique_error<br />  this_type;<br /><br />  typedef ErrorTag<br />  tag;<br /><br />  typedef decltype(unique_error_default(tag()))<br />  type;<br /><br />  class static_error<br />  {<br />  private:<br />    type value;<br />  };<br /><br />  static static_error cast(type raw);<br />  static this_type make(type raw);<br />  static this_type make(const static_error&amp; other);<br /><br />  ~unique_error();<br /><br />  unique_error();<br />  unique_error(static_error other);<br />  unique_error(unique_error &amp;&amp; other);<br />  unique_error(const unique_error&amp; other);<br /><br />  void swap(unique_error&amp; other);<br />  unique_error&amp; operator=(unique_error other);<br /><br />  operator<br />  typename unspecified_bool&lt;this_type&gt;::type() const;<br /><br />  this_type&amp; reset();<br />  this_type&amp; reset(type raw);<br />  type release();<br /><br />  type get() const;<br />  bool try_ok() const;<br />  bool ok() const;<br /><br />  const this_type&amp; suppress() const;<br />  this_type&amp; suppress();<br /><br />  void throw_if(const std::string&amp; message) const;<br />  void throw_if(const char* message = NULL) const;<br /><br />private:<br />  type value;<br />  mutable Disposition::type disposition;<br />};<br /></pre>