---
layout: post
title: error codes in Windows
date: '2011-09-08T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- error handling
- programming
modified_time: '2011-09-20T09:41:15.951-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-4663067203489462591
blogger_orig_url: http://kirkshoop.blogspot.com/2011/09/error-codes-in-windows.html
---

<p><strong>Differences between and best practices for <code>WINERROR</code>, <code>HRESULT</code>, <code>RPC_STATUS</code>, <code>SECURITY_STATUS</code> and <code>NTSTATUS</code>?</strong></p><h3>Why would a developer care?</h3> <p>These error types and their values are an often ignored part of the API contract. Using the return value incorrectly has the same type of consequences as using a cast to pass the wrong data type to a parameter of an API, code just doesn't work, and often fails first in the wild. </p><p>I recently began running into code like this: <pre class="prettyprint lang-cpp"><br />// ERROR_SUCCESS is a WINERROR value<br />NTSTATUS status = ERROR_SUCCESS;<br />WCHAR* buffy;<br /><br />buffy = (WCHAR*)malloc(1);<br />if (buffy == NULL)<br />{<br />  // this is an HRESULT value<br />  status = E_OUTOFMEMORY;<br />}<br /><br />// not only is this a WINERROR value, but HRESULT and<br />// NTSTATUS have many success values, not just one<br />if (status != ERROR_SUCCESS)<br />{<br />  return status;<br />}<br /></pre></p><p>I went searching for information about what each type is and the relationships between them and how to use them correctly. Here is what I learned. </p><p>They are all 32bit values, some signed some unsigned. Some are defined in terms of bit fields and require macros or inline-functions to check their current state. Others are straight enumerations.  </p><p>One of the complexities is best demonstrated with the <code>HRESULT</code> type. Lets look at the out of memory condition. Here are some of the possible encodings: <table border="1" rules="all" width="100%"><tr><th>Expression</th><th>HRESULT value</th></tr><tr><td><code>E_OUTOFMEMORY</code></td><td>0x8007000E</td></tr><tr><td><code>HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY)</code></td><td>0x8007000E</td></tr><tr><td><code>HRESULT_FROM_NT(STATUS_NO_MEMORY)</code></td><td>0xD0000017</td></tr><tr><td><code>HRESULT_FROM_NT(<br />NTSTATUS_FROM_WIN32(ERROR_OUTOFMEMORY))</code></td><td>0xD007000E</td></tr><tr><td><code>STG_E_INSUFFICIENTMEMORY</code></td><td>0x80030008</td></tr><tr><td><code>NTE_NO_MEMORY</code></td><td>0x8009000E</td></tr></table></p><p>There was some effort to make the values agree across the different expressions. </p><p>Many Api's will pick a set of return codes and then build internal maps from all the errors they receive from other Api's to the set they have decided to return. Thus most code calling Api's can expect that only one encoding will be returned. </p><p><h3>Primary Windows Error Types</h3>There will be subsequent posts that expand on each of these types. Here is a summary: </p><p><h3><a href="{{ site.baseurl }}{% post_url 2011-09-13-winerror %}">WINERROR</a></h3></p><table border="1" rules="all" width="100%"><tr><th>Include</th><td>winerror.h</td></tr><tr><th>Type</th><td>DWORD</td></tr><tr><th>Structure</th><td>values in the range 0-16384</td></tr><tr><th>Success</th><td>value == ERROR_SUCCESS</td></tr><tr><th>Failure</th><td>value != ERROR_SUCCESS</td></tr><tr><th>Conversions</th><td>HRESULT_FROM_WIN32(value)<br />NTSTATUS_FROM_WIN32(value)</td></tr></table><p><h3><a href="{{ site.baseurl }}{% post_url 2011-09-15-hresult %}">HRESULT</a></h3></p><table border="1" rules="all" width="100%"><tr><th>Include</th><td>winerror.h</td></tr><tr><th>Type</th><td>HRESULT</td></tr><tr><th>Structure</th><td>[1bit Severity]<br />[1bit Reserved]<br />[1bit Customer]<br />[1bit FACILITY_NT_BIT]<br />[12bit Facility]<br />[16bit Code]</td></tr><tr><th>Success</th><td>SUCCEEDED(value)</td></tr><tr><th>Failure</th><td>FAILED(value)</td></tr><tr><th>Conversions</th><td>HRESULT is a superset<br /> of all the other error types.<br /> They all have lossless conversions <br />to HRESULT but it doesn't have <br />lossless conversions to anything else</td></tr></table><p><h3>NTSTATUS</h3></p><table border="1" rules="all" width="100%"><tr><th>Include</th><td><pre class="prettyprint lang-cpp"><br />#define WIN32_NO_STATUS<br />#include &lt;windows.h&gt;<br />#undef WIN32_NO_STATUS<br /><br />#include &lt;winternl.h&gt;<br />#include &lt;ntstatus.h&gt;<br /></pre></td></tr><tr><th>Type</th><td>NTSTATUS</td></tr><tr><th>Structure</th><td>[2bit Severity]<br />[1bit Customer]<br />[1bit Reserved]<br />[12bit Facility]<br />[16bit Code]</td></tr><tr><th>Success</th><td>NT_SUCCESS(value)</td></tr><tr><th>Failure</th><td>!NT_SUCCESS(value)</td></tr><tr><th>Other<br />Tests</th><td>NT_INFORMATIONAL(value)<br />NT_WARNING(value)<br />NT_ERROR(value)</td></tr><tr><th>Conversions</th><td>HRESULT_FROM_NT(value)</td></tr></table><p><h3>Derived/Subset Windows Error Types</h3></p><p><h3>RPC_STATUS</h3></p><table border="1" rules="all" width="100%"><tr><th>Include</th><td>rpcnterr.h</td></tr><tr><th>Type</th><td>RPC_STATUS</td></tr><tr><th>Structure</th><td>A subset of the WINERROR values, redefined as RPC_S_...</td></tr><tr><th>Success</th><td>value == RPC_S_OK</td></tr><tr><th>Failure</th><td>value != RPC_S_OK</td></tr><tr><th>Conversions</th><td>HRESULT_FROM_WIN32(value)<br />NTSTATUS_FROM_WIN32(value)</td></tr></table><p><h3>SECURITY_STATUS</h3></p><table border="1" rules="all" width="100%"><tr><th>Include</th><td>winerror.h</td></tr><tr><th>Type</th><td>SECURITY_STATUS or HRESULT</td></tr><tr><th>Structure</th><td>A subset of the HRESULT values (from FACILITY_NULL and FACILITY_SECURITY)</td></tr><tr><th>Success</th><td>SUCCEEDED(value)</td></tr><tr><th>Failure</th><td>FAILED(value)</td></tr><tr><th>Conversions</th><td></td></tr></table>