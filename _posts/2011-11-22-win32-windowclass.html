---
layout: post
title: win32 window_class
date: '2011-11-22T10:00:00.000-08:00'
author: Kirk
tags:
- win32
- programming
modified_time: '2012-04-23T23:37:08.859-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-457602052699221410
blogger_orig_url: http://kirkshoop.blogspot.com/2011/11/win32-windowclass.html
---

<p>I have been working on a library for building win32 windows. MFC and WTL were both great designs at the time that they were introduced, but C++ has moved on.</p><p>My goals for this library:  </p><ul><li>I wanted to enable the building of window controls like the common controls in windows</li><li>I wanted to draw a distinct line between the window implementation and window usage</li>  <li>I wanted to remove the window message map from the implementation</li>  <li>I wanted to eliminate virtual functions from the implementation</li>  <li>I wanted to enable exception based implementations without requiring them</li></ul><h2>Code Walkthrough</h2><pre class="prettyprint lang-cpp"><br />template&lt;typename WindowClassTag&gt;<br />struct traits {<br />  typedef<br />    decltype(window_class_traits(WindowClassTag()))<br />  type;<br />};<br /></pre><p><code class="prettyprint lang-cpp">traits</code> encapsulates the lookup of a type that provides traits. the lookup is done using ADL (argument dependent lookup) using the WindowClassTag to cause the compiler to find the <code class="prettyprint lang-cpp">window_class_traits</code> function that is in the same namespace as the provided WindowClassTag. The type returned from this is arbitrary as long as it has the typedefs that <code class="prettyprint lang-cpp">window_class</code> makes reference to. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename WindowClassTag&gt;<br />LRESULT CALLBACK WindowCallback(<br />  HWND hWnd,<br />  UINT message,<br />  WPARAM wParam,<br />  LPARAM lParam);<br /></pre><p>This is the <code class="prettyprint lang-cpp">WNDPROC</code> implementation where all the magic happens. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename WindowClassTag&gt;<br />class window_class {<br />public:<br />  typedef<br />    WindowClassTag<br />  tag;<br /><br />  typedef<br />    typename traits&lt;tag&gt;::type<br />  traits;<br /></pre><p>start of the declaration of <code class="prettyprint lang-cpp">window_class</code> including some simple typedefs to shorten usage inside <code class="prettyprint lang-cpp">window_class</code></p><pre class="prettyprint lang-cpp"><br />  static ATOM Register();<br /><br />  template&lt;typename T&gt;<br />  static ATOM Register(T &amp;&amp; t);<br /></pre><p>overloads of the static <code class="prettyprint lang-cpp">Register</code> function. when called these will register the window class. </p><pre class="prettyprint lang-cpp"><br />private:<br />  ~window_class();<br />  window_class();<br />  window_class(window_class&amp;);<br />  window_class&amp; operator=(window_class&amp;);<br />};<br /></pre><p>the end of <code class="prettyprint lang-cpp">window_class</code> which prevents any instances of <code class="prettyprint lang-cpp">window_class</code> from being made, this is a static only class. </p><p>The next post will show the Register implementations.. </p>