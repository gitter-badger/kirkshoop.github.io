---
layout: post
title: make_range_raw
date: '2011-10-20T10:00:00.000-07:00'
author: Kirk
tags:
- programming
modified_time: '2011-10-20T10:00:00.293-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-1894954526078136054
blogger_orig_url: http://kirkshoop.blogspot.com/2011/10/makerangeraw.html
---

<p>I wrote a range library some years ago and then found a proposal to include a <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2068.html">range library</a> in the std library. </p><p>I adopted the proposed library and over time I have added additional features to ease usage of C APIs. One feature I added is <code class="prettyprint lang-cpp">make_range_raw</code>. </p><p><code class="prettyprint lang-cpp">make_range</code> works by requiring that the Range passed in has support for the <code class="prettyprint lang-cpp">begin</code> and <code class="prettyprint lang-cpp">end</code> free-functions. This produces <code class="prettyprint lang-cpp">range&lt;Iterator&gt;</code> where <code class="prettyprint lang-cpp">Iterator</code> is a raw pointer for built-in arrays but uses the iterator type defined by the Range when it is a collection like <code class="prettyprint lang-cpp">vector</code> or <code class="prettyprint lang-cpp">wstring</code>. This is the desired behavior for <code class="prettyprint lang-cpp">make_range</code> but when trying to interface between collections and C APIs it would be better to access the raw pointer for contiguous array collections like <code class="prettyprint lang-cpp">vector</code> and <code class="prettyprint lang-cpp">wstring</code>. </p><p><code class="prettyprint lang-cpp">make_raw_range</code> requires that the collection support raw access via <code class="prettyprint lang-cpp">operator []</code>. Using <code class="prettyprint lang-cpp">&amp;r[0]</code> for <code class="prettyprint lang-cpp">begin</code> and <code class="prettyprint lang-cpp">&amp;r[0] + size(r)</code> for <code class="prettyprint lang-cpp">end</code> produces <code class="prettyprint lang-cpp">range&lt;Iterator&gt;</code> where <code class="prettyprint lang-cpp">Iterator</code> is always a raw pointer. (for well behaved collections this is true. <code class="prettyprint lang-cpp">vector&lt;bool&gt</code> is not well behaved) </p><h2>Implementation</h2><p>maintained <a href="http://github.com/kirkshoop/libraries">here</a></p><pre class="prettyprint lang-cpp"><br />template&lt; class Range &gt;<br />auto<br />make_range_raw(Range &amp;&amp; r) -&gt;<br />decltype(<br />  make_range(<br />      &amp;r[0],<br />      &amp;r[0] + size(r)<br />  )<br />)<br />{<br />  if (size(r) == 0) {<br />    decltype(<br />      make_range(<br />          &amp;r[0],<br />          &amp;r[0] + size(r)<br />      )<br />    ) result;<br />    return result;<br />  }<br />  return make_range(<br />      &amp;r[0],<br />      &amp;r[0] + size(r)<br />      );<br />}<br /><br />template&lt; class Range &gt;<br />auto<br />make_range_raw(<br />  Range &amp;&amp; r,<br />  typename<br />  range_difference&lt;Range&gt;::type advance_begin,<br />  typename<br />  range_difference&lt;Range&gt;::type advance_end<br />) -&gt;<br />decltype(<br />  make_range(<br />      &amp;r[0],<br />      &amp;r[0] + size(r)<br />  )<br />)<br />{<br />  decltype(<br />    make_range(<br />        &amp;r[0],<br />        &amp;r[0] + size(r)<br />    )<br />  ) result;<br />  if (size(r) != 0) {<br />    result = make_range(<br />        &amp;r[0],<br />        &amp;r[0] + size(r)<br />        );<br />  }<br />  result.advance_begin(advance_begin);<br />  result.advance_end(advance_end);<br />  return result;<br />}<br /></pre> 