---
layout: post
title: WINERROR
date: '2011-09-13T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- error handling
- programming
modified_time: '2011-09-13T10:00:01.341-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-5920767144214959450
blogger_orig_url: http://kirkshoop.blogspot.com/2011/09/winerror.html
---

<p><code>WINERROR</code> has it's roots in DOS which is why it is also referred to as DosError. <code>RtlNtStatusToDosError()</code> is an example which will be discussed more later. DOS errors were in turn derived from the C standard library <code>errno</code>. </p><p>Values of <code>WINERROR</code> are defined in <code>winerror.h</code> and look like <code>ERROR_SUCCESS</code>. They are an enumeration that are expected to fit in the lower 16bits of the 32bit <code>WINERROR</code> type, more on that later. <code>WINERROR</code> values are sometimes returned through the API result, but often an API will return a <code>BOOL</code> or <code>HANDLE</code> and pass any errors to SetLastError() and then return FALSE or an invalid-handle, the caller will retrieve the WINERROR by calling <code>GetLastError()</code>. <code>ERROR_SUCCESS</code> is the only success value for <code>WINERROR</code>. </p><p><h4>Api Examples:</h4><pre class="prettyprint lang-cpp"><br />DWORD ApiReturningWinerror(HANDLE handle)<br />{<br />  if (handle == INVALID_HANDLE_VALUE) {<br />    return ERROR_INVALID_PARAMETER;<br />  }<br />  return ERROR_SUCCESS;<br />}<br /><br />DWORD winerror = ERROR_SUCCESS;<br />HANDLE handle = INVALID_HANDLE_VALUE;<br />winerror = ApiReturningWinerror(handle);<br />if (winerror != ERROR_SUCCESS)<br />{<br />  printf("ApiReturningWinerror returned %d", winerror);<br />  exit();<br />}<br /><br />BOOL ApiReturningBool(HANDLE handle)<br />{<br />  if (handle == INVALID_HANDLE_VALUE) {<br />    SetLastError(ERROR_INVALID_PARAMETER);<br />    // The caller should call GetLastError()<br />    return FALSE;<br />  }<br />  // the common pattern is that SetLastError<br />  // is only called on failure.<br />  // Thus the caller should NOT call GetLastError()<br />  return TRUE;<br />}<br /><br />DWORD winerror = ERROR_SUCCESS;<br />HANDLE handle = INVALID_HANDLE_VALUE;<br />if (!ApiReturningBool(handle))<br />{<br />  winerror = GetLastError();<br />  printf("ApiReturningBool returned %d", winerror);<br />  exit();<br />}<br /></pre></p><p><h4>Conversions to <code>WINERROR</code></h4><pre class="prettyprint lang-cpp"><br />NTSTATUS ntstatus = STATUS_SUCCESS;<br />DWORD winerror = RtlNtStatusToDosError(ntstatus);<br />if (winerror == ERROR_MR_MID_NOT_FOUND)<br />{<br />  // there is no conversion<br />  return ERROR_UNIDENTIFIED_ERROR;<br />#if 0<br />  // The following is common, but doesn't work out well<br />  // especially when combined with HRESULT_FROM_WIN32<br />  // and NTSTATUS_FROM_WIN32<br />  return ntstatus;<br />#endif<br />}<br /><br />HRESULT hr = S_OK;<br />DWORD winerror = ERROR_SUCCESS;<br />if (SUCCEEDED(hr))<br />{<br />  winerror = S_OK;<br />} else if (HRESULT_FACILITY(hr) == FACILITY_WIN32)<br />{<br />  winerror = HRESULT_SCODE(hr);<br />} else<br />{<br />  winerror = ERROR_UNIDENTIFIED_ERROR;<br />}<br /></pre></p><p><h4>Conversions from <code>WINERROR</code></h4><pre class="prettyprint lang-cpp"><br />DWORD winerror = ERROR_SUCCESS;<br />HRESULT hr = HRESULT_FROM_WIN32(winerror);<br /><br />DWORD winerror = ERROR_SUCCESS;<br />NTSTATUS ntstatus = NTSTATUS_FROM_WIN32(winerror);<br /></pre></p><p>Both of the FROM_WIN32 macros work by masking only the lower 16bits of the WINERROR value into the resulting NTSTATUS or HRESULT </p>