---
layout: post
title: monitor_smartcard_readers implementation
date: '2012-04-05T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- smart card
- programming
modified_time: '2012-04-05T23:31:50.446-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-2715398461989271877
blogger_orig_url: http://kirkshoop.blogspot.com/2012/04/monitorsmartcardreaders-implementation.html
---

<p>The Win32 API to monitor smart card readers is <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'SCardGetStatusChange'%29"><code class="prettyprint lang-cpp">SCardGetStatusChange</code></a>. However its usage is sufficiently complex and arcane that a post like this is warranted to show usage. </p><p><a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'SCardGetStatusChange'%29"><code class="prettyprint lang-cpp">SCardGetStatusChange</code></a> blocks until a change takes place at which point it returns. An array containing state for each reader is passed in to indicate the state as understood by the caller and when the function detects a difference between the actual state and the state in the array the function updates the array with the new state and returns. The caller then processes the changes and then calls back with its new understanding. </p><pre class="prettyprint lang-cpp"><br />template&lt;<br />  typename SetContext, <br />  typename ClearContext,<br />  typename Wait,<br />  typename Report<br />&gt;<br />unique_winerror monitor_smartcard_readers(<br />  SetContext &amp;&amp; setContext,<br />  ClearContext &amp;&amp; clearContext,<br />  Wait &amp;&amp; wait,<br />  Report &amp;&amp;  report<br />)<br />{<br />  unique_winerror winerror;<br /><br /></pre><p>These hold the output of SCardListReaders and the input/output for <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'SCardGetStatusChange'%29"><code class="prettyprint lang-cpp">SCardGetStatusChange</code></a>. In fact the readers elements contain pointers into the readernames array. This is why readernames is first so that its lifetime exceeds the lifetime of readers. There is additional code to maintain this lifetime contract further down. </p><pre class="prettyprint lang-cpp"><br />  std::vector&lt;wchar_t&gt; readernames;<br />  std::vector&lt;SCARD_READERSTATE&gt; readers;<br /><br />  while (winerror) {<br /></pre><p>make sure that the smart card service has started and that the loop has not been cancelled </p><pre class="prettyprint lang-cpp"><br /><br />    if (!std::forward&lt;Wait&gt;(wait)()) {<br />      return winerror_cast(SCARD_E_CANCELLED);<br />    }<br /><br />    monitor_error_contract(<br />    [&amp;]() {<br /><br />      unique_close_scardcontext context;<br />      ON_UNWIND_AUTO(<br />        [&amp;] {<br />          std::forward&lt;ClearContext&gt;(clearContext)();<br />        }<br />      );<br /><br /></pre><p>need a fresh context whenever we start over. lots of system changes could have caused this restart including the smart card service stopping. </p><pre class="prettyprint lang-cpp"><br /><br />      winerror.reset(<br />        SCardEstablishContext(<br />            SCARD_SCOPE_USER,<br />            NULL,<br />            NULL,<br />            context.replace()<br />        )<br />      );<br />      if (!winerror || !context) {<br />        return;<br />      }<br /><br />      std::forward&lt;SetContext&gt;(setContext)(context.get());<br /><br /></pre><p>make sure that the loop has not been cancelled. without this second wait there is a race where the new context is not cancelled because the caller cancelled the context at a time when there was no context. </p><pre class="prettyprint lang-cpp"><br /><br />      if (!std::forward&lt;Wait&gt;(wait)()) {<br />        winerror = winerror_cast(SCARD_E_CANCELLED);<br />        return;<br />      }<br /><br />      if (readers.empty()) {<br /></pre><p>Windows allows smart card readers to be inserted and removed from the machine. In order to support these Plug-and-Play events a static reader name was defined so that <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'SCardGetStatusChange'%29"><code class="prettyprint lang-cpp">SCardGetStatusChange</code></a> can report PnP changes. the make function defaults the initial state to unaware which causes <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'SCardGetStatusChange'%29"><code class="prettyprint lang-cpp">SCardGetStatusChange</code></a> to return immediately with the actual PnP state. </p><pre class="prettyprint lang-cpp"><br />        readers.push_back(<br />          make(L"\\\\?PnP?\\Notification")<br />        );<br />      }<br /><br />      for (;;) {<br />        auto readersstaterange = lib::rng::make_range_raw(<br />          readers<br />        );<br /><br />        winerror.reset(<br />          SCardGetStatusChange(<br />              context.get(),<br />              INFINITE,<br />              readersstaterange.begin(),<br />              lib::rng::size_cast&lt;DWORD&gt;(<br />                readersstaterange.size()<br />              )<br />          )<br />        );<br />        if (!winerror) {<br />          // exit<br />          return;<br />        }<br /></pre><p>report the smart card reader state </p><pre class="prettyprint lang-cpp"><br />        auto readersrange = lib::rng::make_range_raw(<br />          readers, <br />          0, <br />          -1<br />        );<br />        if (!readersrange.empty()) {<br />          std::forward&lt;Report&gt;(report)(readersrange);<br />        }<br /><br /></pre><p>record the changes now that they have been reported. setting <code class="prettyprint lang-cpp">dwCurrentState = dwEventState</code> is required before calling <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'SCardGetStatusChange'%29"><code class="prettyprint lang-cpp">SCardGetStatusChange</code></a> again or the function will just return immediately to report the same changes. </p><pre class="prettyprint lang-cpp"><br />        for (auto &amp; state : readers) {<br />          state.dwCurrentState = state.dwEventState;<br />        }<br /><br />        if ((<br />            readers.back().dwEventState &amp; <br />            SCARD_STATE_CHANGED<br />          ) == SCARD_STATE_CHANGED<br />        ) {<br />          // Pnp event - list readers.<br />          break;<br />        }<br />      }<br /><br /></pre><p>A PnP event occured. must keep the existing allocations for use while building the new list. </p><pre class="prettyprint lang-cpp"><br />      std::vector&lt;wchar_t&gt; oldreadernames(<br />        std::move(readernames)<br />      );<br />      std::vector&lt;SCARD_READERSTATE&gt; oldreaders(<br />        std::move(readers)<br />      );<br /></pre><p>create a range of the existing reader states that excludes the static pnp state </p><pre class="prettyprint lang-cpp"><br />      auto oldreaderssortedrange = lib::rng::make_range(<br />        oldreaders,<br />        0, <br />        -1<br />      );<br /><br />      LPWSTR concatreaderstrings = nullptr;<br />      ON_UNWIND_AUTO(<br />        [&amp;] { <br />        if (concatreaderstrings) {<br />          SCardFreeMemory(<br />            context.get(), <br />            concatreaderstrings<br />          );<br />        };<br />      }<br />      );<br />      DWORD totallength = SCARD_AUTOALLOCATE;<br /><br />      winerror.reset(<br />        SCardListReaders(<br />            context.get(),<br />            nullptr,<br />            reinterpret_cast&lt;LPWSTR&gt;(&amp;concatreaderstrings),<br />            &amp;totallength<br />        )<br />      );<br /></pre><p>no readers is not an error, just loop around to wait for a reader to be connected </p><pre class="prettyprint lang-cpp"><br />      if (winerror == <br />          winerror_cast(SCARD_E_NO_READERS_AVAILABLE)<br />      ) {<br />        winerror.suppress().release();<br />        return;<br />      } else if (!winerror) {<br />        return;<br />      }<br /></pre><p>save a copy of the reader names because the state array will have pointers into them. </p><pre class="prettyprint lang-cpp"><br />      readernames.assign(<br />        concatreaderstrings, <br />        concatreaderstrings + totallength<br />      );<br /><br />      auto readerstateless = [](<br />        const SCARD_READERSTATE &amp; lhs, <br />        const SCARD_READERSTATE &amp; rhs<br />      ) -&gt; bool {<br />        return _wcsicmp(lhs.szReader, rhs.szReader) &lt; 0;<br />      };<br /><br /></pre><p>all the reader names are concatenated in this array with embedded nulls for each and two nulls to mark the end </p><pre class="prettyprint lang-cpp"><br />      auto cursorreadernames = lib::rng::make_range_raw(<br />        readernames<br />      );<br />      while (<br />        !cursorreadernames.empty() &amp;&amp; <br />        cursorreadernames.front() != L'\0'<br />      ) {<br />        // access the current name<br />        auto namerange = lib::rng::make_range(<br />          cursorreadernames,<br />          0,<br />          wcslen(<br />            cursorreadernames.begin()<br />          ) - cursorreadernames.size()<br />        );<br />        // skip to the next name<br />        cursorreadernames = lib::rng::make_range(<br />          namerange, <br />          namerange.size() + 1, <br />          0<br />        );<br /><br /></pre><p>find this reader in the old list of readers. This list is kept sorted so that <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'std::equal_range'%29"><code class="prettyprint lang-cpp">std::equal_range</code></a> can be used. </p><pre class="prettyprint lang-cpp"><br />        auto oldreader = std::equal_range(<br />          oldreaderssortedrange.begin(),<br />          oldreaderssortedrange.end(),<br />          make(namerange.begin()),<br />          readerstateless<br />        );<br />        if (oldreader.first != oldreader.second) {<br />          // keep the old state for this reader<br />          readers.push_back(*oldreader.first);<br /><br />          // must use the new string allocation,<br />          // the old one will be gone soon<br />          readers.back().szReader = namerange.begin();<br />        } else {<br />          // this reader has not been seen yet.<br />          // make defaults to setting the state to <br />          // unaware, so that the next call to<br />          // SCardGetStatusChange will return <br />          // immediately with the actual state.<br />          readers.push_back(make(namerange.begin()));<br />        }<br />      }<br /></pre><p>keeping the reader states sorted makes the updates more stable and allows the <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'std::equal_range'%29"><code class="prettyprint lang-cpp">std::equal_range</code></a> above instead of a linear find. </p><pre class="prettyprint lang-cpp"><br />      std::sort(<br />        readers.begin(), <br />        readers.end(), <br />        readerstateless<br />      );<br /></pre><p>add PnP state query to the new list. keep the existing state, and keep it at the end of the list, out of the sorted area. </p><pre class="prettyprint lang-cpp"><br />      readers.push_back(oldreaders.back());<br />    }<br />    );<br />  }<br />  return winerror;<br />}<br /></pre><p>Tracking the readers state is only the first step. Future posts will explore tracking cards, certificates and subjects/users </p>