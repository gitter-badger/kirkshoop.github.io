---
layout: post
title: monitor_smartcard_readers usage
date: '2012-04-03T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- smart card
- programming
modified_time: '2012-04-23T23:36:04.277-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-5539398500264297167
blogger_orig_url: http://kirkshoop.blogspot.com/2012/04/monitorsmartcardreaders-usage.html
---

<p>Building a loop to monitor smart cards on windows turns out to be tricky. I have written a function to do this and allow code to be inserted in the necessary places. </p><pre class="prettyprint lang-cpp"><br />template&lt;<br />  typename SetContext, <br />  typename ClearContext,<br />  typename Wait,<br />  typename Report<br />&gt;<br />unique_winerror monitor_smartcard_readers(<br />  SetContext &amp;&amp; setContext,<br />  ClearContext &amp;&amp; clearContext,<br />  Wait &amp;&amp; wait,<br />  Report &amp;&amp;  report<br />);<br /></pre><p>By itself the data produced by this function isn't too interesting, but I have a project in mind that I hope will use it to advantage.</p><p>To use <code class="prettyprint lang-cpp">monitor_smartcard_readers</code> you call the function passing in lambdas for the code to insert. </p><ul><li><strong>setContext</strong> when the function establishes a context it calls this lambda to allow the caller to store the context and use it later to call <a href="http://www.bing.com/search?q=site%3Amsdn.microsoft.com+meta%3ASearch.MSHAttr.APIName%28'SCardCancel'%29"><code class="prettyprint lang-cpp">SCardCancel</code></a></li><li><strong>clearContext</strong> when the function closes the context it calls this function to inform the caller that it is no longer valid.</li><li><strong>wait</strong> when the function needs to wait for the service to become available or check to see if it should exit it calls this lambda. this lambda must return a bool, true for continue and false for exit.</li><li><strong>report</strong> when the function has an update to the status it calls this lambda with a range of reader states.</li></ul><p>A quick example should show how this all stitches together. </p><pre class="prettyprint lang-cpp"><br />void monitor()<br />{<br /></pre><p>First need to get the win32 event handle that is set when the smart card service is running. </p><pre class="prettyprint lang-cpp"><br />  HANDLE waitfor[1] = {SCardAccessStartedEvent()};<br />  ON_UNWIND_AUTO([] {SCardReleaseStartedEvent();});<br /><br />  unique_winerror winerror;<br />  SCARDCONTEXT context = NULL;<br /><br />  while (!winerror) {<br />    winerror = monitor_smartcard_readers(<br /></pre><p>when setContext is called, store the context in the local stack variable.</p><pre class="prettyprint lang-cpp"><br />    [&amp;](SCARDCONTEXT context) {<br />      context = context;<br />    },<br /></pre><p>when clearContext is called, set the local stack variable to NULL</p><pre class="prettyprint lang-cpp"><br />    [&amp;]() {<br />      context = NULL;<br />    },<br /></pre><p>when wait is called, wait for the smart card service to start. If additional threads were in play this might include other events to signal that <code class="prettyprint lang-cpp">monitor_smartcard_readers</code> should exit.</p><pre class="prettyprint lang-cpp"><br />    [&amp;]() -&gt; bool {<br />      if (WAIT_OBJECT_0 != WaitForMultipleObjects(<br />          lib::rng::size(waitfor), <br />          waitfor, <br />          FALSE, <br />          INFINITE<br />        )<br />      ) {<br />        // monitor_smardcard_readers will <br />        // return SCARD_E_CANCELLED<br />        return false;<br />      }<br />      return true;<br />    },<br /></pre><p>when report is called, print out the state changes.</p><pre class="prettyprint lang-cpp"><br />    [&amp;](<br />      lib::rng::range&lt;SCARD_READERSTATE*&gt; readersrange<br />    ) {<br />      std::wcout &lt;&lt; L"---status update---" &lt;&lt; std::endl;<br />      for (auto &amp; state : readersrange) {<br />        auto stateChanges = (<br />          state.dwCurrentState ^ state.dwEventState<br />        ) &amp; std::numeric_limits&lt;unsigned short&gt;::max();<br />        <br />        std::wcout &lt;&lt; L"reader: " &lt;&lt; state.szReader <br />        &lt;&lt; L" changes: " &lt;&lt; <br />           std::hex &lt;&lt; std::showbase &lt;&lt; stateChanges<br />        &lt;&lt; L" state: "<br />        &lt;&lt; ((state.dwEventState == SCARD_STATE_UNAWARE) ? <br />           L" SCARD_STATE_UNAWARE" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_PRESENT) ? <br />           L" SCARD_STATE_PRESENT" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_ATRMATCH) ? <br />           L" SCARD_STATE_ATRMATCH" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_CHANGED) ? <br />           L" SCARD_STATE_CHANGED" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_EMPTY) ? <br />           L" SCARD_STATE_EMPTY" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_EXCLUSIVE) ? <br />           L" SCARD_STATE_EXCLUSIVE" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_IGNORE) ? <br />           L" SCARD_STATE_IGNORE" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_INUSE) ? <br />           L" SCARD_STATE_INUSE" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_MUTE) ? <br />           L" SCARD_STATE_MUTE" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_UNAVAILABLE) ? <br />           L" SCARD_STATE_UNAVAILABLE" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_UNKNOWN) ? <br />           L" SCARD_STATE_UNKNOWN" : L"")<br />        &lt;&lt; ((state.dwEventState &amp; SCARD_STATE_UNPOWERED) ? <br />           L" SCARD_STATE_UNPOWERED" : L"")<br />        &lt;&lt; std::endl; <br />      }<br />      std::wcout &lt;&lt; L"--status update end--" &lt;&lt; std::endl;<br />    }<br />    );<br />  }<br />}<br /></pre><p>Next post will explore the implementation of <code class="prettyprint lang-cpp">monitor_smartcard_readers</code>.. </p>