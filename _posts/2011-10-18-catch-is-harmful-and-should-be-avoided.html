---
layout: post
title: catch(â€¦) is harmful and should be avoided
date: '2011-10-18T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- error handling
- programming
modified_time: '2011-10-18T10:00:06.938-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-7300874947910062235
blogger_orig_url: http://kirkshoop.blogspot.com/2011/10/catch-is-harmful-and-should-be-avoided.html
---

<p>A common use of <code class="prettyprint lang-cpp">catch(...)</code>, even in the STD library implementation, is to free objects or to return to a known state on failure.  </p><p><code class="prettyprint lang-cpp">catch(...)</code> has no information about the exception and therefore there is no way to reason about whether the code in the catch block will corrupt the process. Thus any code in a <code class="prettyprint lang-cpp">catch(...)</code> is a potential danger to the process and the data it manages.  </p><p>Whenever an exception is thrown and the search for a catch encounters a <code class="prettyprint lang-cpp">catch(...)</code> block it must run all the destructors for the code inside the matching <code class="prettyprint lang-cpp">try</code> to get the stack back to the correct state to run the <code class="prettyprint lang-cpp">catch</code> block. At best this modifies the state, when it doesn't corrupt it. Then the catch block is likely to  immediately rethrow the exception with the state at the most relevant part of the stack (where the <code class="prettyprint lang-cpp">throw</code> occurred) erased. </p><p>This erasure is particularly unwanted when the exception is ultimately not handled and a Windows Error Report is generated with a dump of the state after the unhelpful <code class="prettyprint lang-cpp">catch(...)</code> erased the part that would be most important to determine how to fix the bug. </p><p>Windows Error Reporting (WER) has changed the way I write code. I try to exit the process quickly (FAIL_FAST) whenever I reach an unexpected state. When there are no <code class="prettyprint lang-cpp">catch(...)</code> blocks in the way I get great bugs generated directly from the WER with no repro necessary and I quickly issue a fix. </p><p>The good thing is that none of the <code class="prettyprint lang-cpp">catch(...)</code> blocks are needed and that the replacements do not corrupt the state when the exception type is not known to the call stack. The common case where you might use <code class="prettyprint lang-cpp">catch(...)</code> to free an allocation or restore state can be replaced by an unwinder. In the case where <code class="prettyprint lang-cpp">catch(...)</code> is used to suppress an exception it should be replaced with a <code class="prettyprint lang-cpp">FAIL_FAST_ON_THROW([]{});</code>. This will not suppress the exception (which as described earlier invites data corruption), instead when an exception that is not expected and handled reaches this barrier a WER will be generated and the process will exit without any corruption. </p><p>These boundaries can be enforced using <a href="http://kirkshoop.blogspot.com/2011/09/error-contract-functions.html">error contract functions</a>: </p><pre class="prettyprint lang-cpp"><br />template&lt;typename Function&gt;<br />HRESULT HResultErrorContract(Function &amp;&amp; function)<br />{<br />  HRESULT result = S_OK;<br />  FAIL_FAST_ON_THROW(<br />  [&amp;] {<br />    // any C++ exception that is uncaught or any SEH<br />    // will cause the process to exit<br />    try<br />    {<br />      unique_hresult hresult = (<br />        std::forward&lt;Function&gt;(function)());<br />      result = hresult.get();<br />    } catch (const std::bad_alloc&amp;) {<br />      result = E_OUTOFMEMORY;<br />    } catch (const unique_winerror::exception&amp; e) {<br />      result = HRESULT_FROM_WIN32(e.get());<br />    } catch (const unique_hresult::exception&amp; e) {<br />      result = e.get();<br />    }<br />  }<br />  );<br />  return result;<br />}<br /><br />HRESULT MyDllExport()<br />{<br />  // no exception can get past<br />  // HResultErrorContract<br />  return HResultErrorContract(<br />  [&amp;]() -&gt; unique_hresult {<br />    // It is safe to throw C++ exceptions<br />    unique_hresult hresult;<br />    // RestoreState is only called on failure<br />    ON_UNWIND(unwindWork, []{ RestoreState(); });<br />    hresult = Work();<br />    if (hresult.ok()) {<br />      unwindWork.Dismiss();<br />    }<br />    return hresult;<br />  }<br />}<br /></pre> 