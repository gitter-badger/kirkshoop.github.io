---
layout: post
title: console app that monitors smart cards
date: '2012-04-17T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- smart card
- programming
modified_time: '2012-04-17T10:00:00.520-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-7596858369371840421
blogger_orig_url: http://kirkshoop.blogspot.com/2012/04/console-app-that-monitors-smart-cards.html
---

<p>Here is a console app that demonstrates how to tie the smart card functions already covered into a working monitor that prints reader state changes and the certs and subject names for the cards that are present. </p><pre class="prettyprint lang-cpp"><br />#pragma once<br /><br />// Exclude rarely-used stuff from<br />// Windows headers<br />#define WIN32_LEAN_AND_MEAN<br />// skip min/max macros from<br />// Windows Headers<br />#define NOMINMAX<br />// Windows Header Files:<br />#include &lt;windows.h&gt;<br />#include &lt;Unknwn.h&gt;<br />#include &lt;winscard.h&gt;<br />#include &lt;ncrypt.h&gt;<br />#include &lt;Wincrypt.h&gt;<br />#include &lt;credentialprovider.h&gt;<br /><br />// C++ library header files:<br />#include &lt;type_traits&gt;<br />#include &lt;algorithm&gt;<br />#include &lt;new&gt;<br />#include &lt;memory&gt;<br />#include &lt;utility&gt;<br />#include &lt;limits&gt;<br />#include &lt;iterator&gt;<br />#include &lt;thread&gt;<br />#include &lt;future&gt;<br />#include &lt;mutex&gt;<br />#include &lt;vector&gt;<br />#include &lt;iostream&gt;<br />#include &lt;iomanip&gt;<br /><br />// local header files:<br />#define LIBRARIES_NAMESPACE nslib<br />#include &lt;libraries.h&gt;<br />namespace lib = LIBRARIES_NAMESPACE;<br /><br />#include "..\win32project1\scard_monitor.h"<br /></pre><p>Set a breakpoint in each of these functions and see where error codes first make an appearance in this module. the static anchor is a device to make sure that the compiler does not eliminate or fold them together. </p><pre class="prettyprint lang-cpp"><br />void unique_error_report_initiated(<br />  HRESULT value, <br />  unique_hresult_def::tag &amp;&amp;)<br />{<br />  static HRESULT anchor;<br />  anchor = value;<br />}<br /><br />void unique_error_report_reset(<br />  HRESULT value, <br />  unique_hresult_def::tag &amp;&amp;)<br />{<br />  static HRESULT anchor;<br />  anchor = value;<br />}<br /><br />void unique_error_report_initiated(<br />  DWORD value, <br />  unique_winerror_def::tag &amp;&amp;)<br />{<br />  static DWORD anchor;<br />  anchor = value;<br />}<br /><br />void unique_error_report_reset(<br />  DWORD value, <br />  unique_winerror_def::tag &amp;&amp;)<br />{<br />  static DWORD anchor;<br />  anchor = value;<br />}<br /></pre><p>Helper functions to print status and certificate properties. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename Certificate&gt;<br />void printCertificates(<br />  lib::rng::range&lt;Certificate&gt; certificates)<br />{<br />  for (auto &amp; key : certificates) {<br />    unique_winerror winerror;<br /><br />    PCCERT_CONTEXT certcontext = (<br />      CertCreateCertificateContext(<br />        X509_ASN_ENCODING | <br />          PKCS_7_ASN_ENCODING,<br />        &amp;key.cert[0],<br />        key.cert.size()<br />      )<br />    );<br />    winerror = make_winerror_if(!certcontext);<br /><br />    if (!winerror) {<br />      std::wcout <br />        &lt;&lt; L"could not get cert context" <br />        &lt;&lt; std::endl;<br />      continue;<br />    }<br /><br />    DWORD sizesubject = 0;<br />    std::wstring subjectname;<br />    for (bool getsize = true; ; getsize = false) {<br />      sizesubject = CertGetNameString(<br />        certcontext,<br />        CERT_NAME_FRIENDLY_DISPLAY_TYPE,<br />        0,<br />        NULL,<br />        getsize ? nullptr : &amp;subjectname[0],<br />        sizesubject<br />      );<br />      if (sizesubject == 1) {<br />        std::wcout <br />          &lt;&lt; L"could not get subject name" <br />          &lt;&lt; std::endl;<br />        break;<br />      }<br />      if (getsize) {<br />        subjectname.resize(sizesubject - 1);<br />      } else {<br />        std::wcout <br />          &lt;&lt; L"key name: " &lt;&lt; key.key.c_str() <br />          &lt;&lt; L" subject name: " &lt;&lt; subjectname.c_str() <br />          &lt;&lt; std::endl;<br />        break;<br />      }<br />    }<br />  }<br />}<br /><br />template&lt;typename Stream&gt;<br />Stream&amp; printSCardState(Stream&amp; stream, DWORD state)<br />{<br />  stream<br />    &lt;&lt; ((state == SCARD_STATE_UNAWARE)  ? <br />      L" SCARD_STATE_UNAWARE" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_PRESENT)  ? <br />      L" SCARD_STATE_PRESENT" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_ATRMATCH)  ? <br />      L" SCARD_STATE_ATRMATCH" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_CHANGED)  ? <br />      L" SCARD_STATE_CHANGED" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_EMPTY)  ? <br />      L" SCARD_STATE_EMPTY" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_EXCLUSIVE)  ? <br />      L" SCARD_STATE_EXCLUSIVE" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_IGNORE)  ? <br />      L" SCARD_STATE_IGNORE" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_INUSE)  ? <br />      L" SCARD_STATE_INUSE" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_MUTE)  ? <br />      L" SCARD_STATE_MUTE" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_UNAVAILABLE)  ? <br />      L" SCARD_STATE_UNAVAILABLE" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_UNKNOWN)  ? <br />      L" SCARD_STATE_UNKNOWN" : L"")<br />    &lt;&lt; ((state &amp; SCARD_STATE_UNPOWERED)  ? <br />      L" SCARD_STATE_UNPOWERED" : L"")<br />  ;<br />  return stream;<br />}<br /><br />int wmain(int argc, WCHAR* argv[])<br />{<br />  unique_winerror winerror;<br />  for (;;) {<br />    SCARDCONTEXT context = NULL;<br /><br />    HANDLE waitfor[] = {SCardAccessStartedEvent()};<br />    ON_UNWIND_AUTO([] {SCardReleaseStartedEvent();});<br /><br />    winerror = smart_card::monitor_smartcard_readers(<br />      [&amp;](SCARDCONTEXT context) {<br />        context = context;<br />      },<br />      [&amp;]() {<br />        context = NULL;<br />      },<br />      [&amp;]() -&gt; bool {<br />        if (WAIT_OBJECT_0 != WaitForMultipleObjects(<br />          lib::rng::size(waitfor), <br />          waitfor, <br />          FALSE, <br />          INFINITE)<br />        ) {<br />          // monitor_smardcard_readers will return <br />          // SCARD_E_CANCELLED<br />          return false;<br />        }<br />        return true;<br />      },<br />      [&amp;](<br />        lib::rng::range&lt;SCARD_READERSTATE*&gt; readersrange<br />      ) {<br />        for (auto &amp; state : readersrange) {<br />          auto stateChanges = (<br />            (state.dwCurrentState ^ state.dwEventState) &amp; <br />              std::numeric_limits&lt;unsigned short&gt;::max()<br />          );<br />          std::wcout<br />            &lt;&lt; L"nothread - "<br />            &lt;&lt; state.szReader<br />            &lt;&lt; L" changes: " <br />            &lt;&lt; std::hex <br />            &lt;&lt; std::showbase <br />            &lt;&lt; stateChanges<br />            &lt;&lt; L"["<br />          ;<br />          printSCardState(std::wcout, stateChanges)<br />            &lt;&lt; L"] state: " <br />            &lt;&lt; std::hex <br />            &lt;&lt; std::showbase <br />            &lt;&lt; state.dwEventState<br />            &lt;&lt; L"["<br />          ;<br />          printSCardState(std::wcout, state.dwEventState)<br />            &lt;&lt; L"]"<br />            &lt;&lt; std::endl<br />          ;<br /><br />          if (<br />            state.dwCurrentState != <br />              SCARD_STATE_UNAWARE &amp;&amp;<br />            ((state.dwEventState &amp; <br />              SCARD_STATE_PRESENT) != <br />                SCARD_STATE_PRESENT ||<br />              stateChanges == SCARD_STATE_INUSE ||<br />              stateChanges == SCARD_STATE_UNPOWERED ||<br />              (state.dwEventState &amp; (<br />                SCARD_STATE_UNPOWERED | <br />                SCARD_STATE_EMPTY | <br />                SCARD_STATE_IGNORE | <br />                SCARD_STATE_UNKNOWN | <br />                SCARD_STATE_UNAVAILABLE | <br />                SCARD_STATE_MUTE)) ||<br />            state.cbAtr == 0)<br />          ) {<br />            // we have seen this reader before <br />            // and one of:<br />            // no card<br />            // only flipped INUSE<br />            // only flipped UNPOWERED<br />            // UNPOWERED EMPTY UNKNOWN UNAVAILABLE MUTE<br />            // no atr<br />            //<br />            // don't try to read the card<br />            continue;<br />          }<br /><br />          CardWithProvider card;<br />          std::tie(winerror, card) = <br />            smart_card::smartcard_name_and_provider(<br />              lib::rng::make_range_raw(state.rgbAtr)<br />          );<br />          if (!winerror) {<br />            continue;<br />          }<br /><br />          KeyWithCertificateVector certificates;<br />          std::tie(winerror, certificates) = <br />            smart_card::smartcard_certificates(<br />              card.kspname);<br />          if (!winerror) {<br />            continue;<br />          }<br /><br />          std::wcout &lt;&lt; L"nothread -"<br />          &lt;&lt; L" kspname: " &lt;&lt; card.kspname.c_str()<br />          &lt;&lt; std::endl;<br /><br />          printCertificates(<br />            lib::rng::make_range_raw(certificates)<br />          );<br />        }<br />      }<br />    );<br />    winerror.suppress();<br />  }<br /><br />  return 0;<br />}<br /></pre>