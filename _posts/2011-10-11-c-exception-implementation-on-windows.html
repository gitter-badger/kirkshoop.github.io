---
layout: post
title: C++ exception implementation on Windows
date: '2011-10-11T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- error handling
- programming
modified_time: '2011-10-11T10:00:03.868-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-3481991977351071291
blogger_orig_url: http://kirkshoop.blogspot.com/2011/10/c-exception-implementation-on-windows.html
---

<p>On windows c++ exceptions are implemented using an exception facility provided by the OS. The OS exception system (Structured Exception Handling or SEH) does not have the same semantics as C++ exception handling. </p><p>Windows SEH works in C or assembly code as well as C++. the C++ compiler and the OS are both involved. SEH is used to report many runtime errors and logic errors in code. Often they are unrecoverable. Access Violation, Stack Overflow, RPC errors, are all reported using SEH exceptions. Here is some code that uses SEH </p><pre class="prettyprint lang-cpp"><br />LONG WINAPI MyExceptionFilter(<br />  __in  struct _EXCEPTION_POINTERS *ExceptionInfo,<br />  __in DWORD ExceptionCode<br />)<br />{<br />    // code in an exception filter must be <br />    // very robust, careful and have minimal <br />    // dependencies. often t\filters are run <br />    // at times of extreme duress or with <br />    // malicious intent<br /><br />    //<br />    // must return one of these three values:<br /><br />    // EXCEPTION_CONTINUE_EXECUTION<br />    //   re execute the instruction that <br />    //   triggered the exception. if it<br />    //   fails again the new exception <br />    //   will be marked<br />    //   EXCEPTION_NONCONTINUABLE_EXCEPTION<br /><br />    // EXCEPTION_CONTINUE_SEARCH<br />    //   call the next registered <br />    //   exception filter<br /><br />    // EXCEPTION_EXECUTE_HANDLER<br />    //   run all the finally blocks for<br />    //   nested try's and then runs the <br />    //   __except block and then runs <br />    //   the finally block and then <br />    //   continues after the __try/<br />    //   __except/__finally<br /><br />    return EXCEPTION_CONTINUE_SEARCH;<br />}<br /><br />void* ptr = nullptr;<br />__try<br />{<br />  ptr = malloc(1);<br />  if (!ptr) {<br />    __leave;<br />  }<br />  Work(ptr); // might AV or overflow stack, etc..<br />  // or explicitly call RaiseException() to <br />  // raise an SEH<br />} __except (<br />    // registers MyExceptionFilter for any SEH<br />    // that occurs in the __try<br />    MyExceptionFilter(<br />      GetExceptionInformation(),<br />      GetExceptionCode()))<br />{<br />  // MyExceptionFilter returned <br />  // EXCEPTION_EXECUTE_HANDLER<br />}<br />__finally()<br />{<br />  // the stack is unwinding due to a return<br />  // or an exception that is handled here or<br />  // up the stack from here<br />  if (ptr) {<br />    free(ptr);<br />  }<br />}<br /></pre><p>Hopefully it is obvious that an SEH exception will not cause C++ destructors to be called without some more work. The C++ compiler supports __try/__except/__finally and also supports try/catch, but not in the same function. Also, the C++ compiler will not allow __try/__except/__finally to be used in a function that has a local variable with a destructor. </p><p><em>Disclaimer - this is inaccurate yet provides a mental picture suitable for reasoning about the intersection of SEH and C++. - </em>When the C++ compiler sees a try it inserts a __try, and an __except with a filter that is passed information about the catch clauses and catch blocks and destructors in scope. The C++ compiler replaces each throw with a RaiseException() that stores the exception object in the SEH ExceptionInformation. Then the SEH mechanism calls the registered filter and the filter tries to match the catch block type to the exception object type. If a catch block matches the filter calls the appropriate destructors and the appropriate catch block and then returns EXCEPTION_EXECUTE_HANDLER to continue after the catch block. </p><p>The C++ compiler also does not implement throw() semantics. Using what we know we can implement those semantics: </p><pre class="prettyprint lang-cpp"><br />#define FAIL_FAST_FILTER() \<br />  __except(FailFastFilter(GetExceptionInformation())) \<br />  { \<br />  } do {} while(0,0)<br /><br />inline<br />LONG WINAPI FailFastFilter(<br />  __in  struct _EXCEPTION_POINTERS* exceptionInfo)<br />{<br />  RaiseFailFastException(<br />    exceptionInfo - &gt; ExceptionRecord,<br />    exceptionInfo - &gt; ContextRecord,<br />    0);<br />  return EXCEPTION_CONTINUE_SEARCH;<br />}<br /><br />template&lt;typename Function&gt;<br />auto FailFastOnThrow(<br />  Function &amp;&amp; function) -&gt; decltype(<br />      std::forward&lt;Function&gt;(function)())<br />{<br />  //<br />  // __ try must be isolated in its own<br />  // function in order for the compiler<br />  // to reason about C++ unwind in the<br />  // calling and called functions.<br />  //<br />  __try {<br />    return std::forward &lt;Function &gt;(function)();<br />  }<br />  FAIL_FAST_FILTER();<br />}<br /><br />#define FAIL_FAST_ON_THROW(Function) \<br />  FailFastOnThrow((Function))<br /><br />HRESULT MyDllExport()<br />{<br />  HRESULT result = S_OK;<br />  FAIL_FAST_ON_THROW(<br />  [&amp;] {<br />    // any C++ exception that is uncaught or any SEH<br />    // will cause the process to exit<br />    try<br />    {<br />      unique_hresult hresult;<br />      hresult = Work();<br />      result = hresult.get();<br />    } catch (const std::bad_alloc&amp;) {<br />      result = E_OUTOFMEMORY;<br />    } catch (const unique_winerror::exception&amp; e) {<br />      result = HRESULT_FROM_WIN32(e.get());<br />    } catch (const unique_hresult::exception&amp; e) {<br />      result = e.get();<br />    }<br />  }<br />  );<br />  return result;<br />}<br /></pre><p>Next time we will build error contract functions to reduce the amount of code in each export. </p>