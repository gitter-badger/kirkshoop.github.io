---
layout: post
title: error contract functions
date: '2011-10-13T10:00:00.000-07:00'
author: Kirk
tags:
- win32
- error handling
- programming
modified_time: '2011-10-13T10:00:04.417-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-5139860531581282045
blogger_orig_url: http://kirkshoop.blogspot.com/2011/09/error-contract-functions.html
---

<p>In code for Windows there are many places that are boundaries across which C++ exceptions cannot safely travel. </p><p>The most accurate way to describe the boundaries is to say that C++ exceptions cannot be sent across modules (exe and all and sys are all examples of modules). It may not be completely clear from that statement when a module boundary is crossed. Here are some examples that should help reason about when a module boundary is being crossed. The most straight forward situation is when a function is exported from a dll so that it can be called from a different module. but it can get considerably more abstract when you think of dll methods that return COM interfaces or structs containing function pointers. Then add all the PROC's used in Windows programming. WNDPROC, DLGPROC and so many other PROC's are all functions in one module called from a different module. </p><p>Any C++ exceptions that occur in these boundary functions must be stopped before the calling module try's to process them. The problem is that exception types are not always the same in each module. if the calling module try's to process an exception from a different module it could be that the type has different members or that the size of the members is different and the constructors, destructors and other methods compiled into the calling module are the wrong methods for an instance of the type that was constructed in the called module. Crashes or data corruption will ensue. </p><p>When building all these boundary functions it becomes important to centralize the catch blocks used to convert exceptions to errors and the FAIL_FAST for uncaught exceptions. Without centralization there is a lot of duplicated code. </p><p>With lambdas and perfect-forwarding using r-value references we can build error contract functions that will centralize the boundary contract for errors in one function and apply that contract to many functions. Here is an implementation of a error contract function for use with boundary functions that return HRESULT. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename Function&gt;<br />HRESULT HResultErrorContract(Function &amp;&amp; function)<br />{<br />  HRESULT result = S_OK;<br />  FAIL_FAST_ON_THROW(<br />  [&amp;] {<br />    // any C++ exception that is uncaught or any SEH<br />    // will cause the process to exit<br />    try<br />    {<br />      unique_hresult hresult = (<br />        std::forward&lt;Function&gt;(function)());<br />      result = hresult.get();<br />    } catch (const std::bad_alloc&amp;) {<br />      result = E_OUTOFMEMORY;<br />    } catch (const unique_winerror::exception&amp; e) {<br />      result = HRESULT_FROM_WIN32(e.get());<br />    } catch (const unique_hresult::exception&amp; e) {<br />      result = e.get();<br />    }<br />  }<br />  );<br />  return result;<br />}<br /><br />HRESULT MyDllExport()<br />{<br />  // no exception can get past<br />  // HResultErrorContract<br />  return HResultErrorContract(<br />  [&amp;]() -&gt; unique_hresult {<br />    // It is safe to throw C++ exceptions<br />    unique_hresult hresult;<br />    hresult = Work();<br />    return hresult;<br />  }<br />}<br /></pre><p>error contract functions are specific to the module they are used in, they are not candidates for a general shared template library. This is because each module uses different libraries and therefore has different exceptions that must be caught and translated. </p>