---
layout: post
title: window message dispatcher
date: '2011-12-01T10:00:00.000-08:00'
author: Kirk
tags:
- win32
- programming
modified_time: '2011-12-05T09:15:32.594-08:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-5929532321392248212
blogger_orig_url: http://kirkshoop.blogspot.com/2011/12/window-message-dispatcher.html
---

<p>Time to look at the window message dispatcher. This is the third major implementation. so far. </p><p>Callers of <code class="prettyprint lang-cpp">dispatch</code> should call DefWindowProc if this returns <code class="prettyprint lang-cpp">result.first == false</code>.  </p><p>One goal was to eliminate manual maintenance of a message-map from message id to function. Other goals included pay-for-use performance characteristics, code driven instead of data driven design, no virtual function calls and allow source debugging even in the macros (which are unfortunately required until C++ supports 'templated' names).  </p><p>The current approach inspects the specified target class instance for a function matching each supported windows message. The parameters for the function are determined using the HANDLE_MSG_... macros from windowsx.h in the SDK. So if the target class has a function matching <code class="prettyprint lang-cpp">LRESULT OnPaint(const lib::wnd::Context&lt;Tag&gt;&amp; context)</code> then code to forward the WM_PAINT message to the function is included, otherwise the code is omitted. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename WindowClassTag, typename Target&gt;<br />std::pair&lt;bool, LRESULT&gt;<br />dispatch(<br />  Target target,<br />  const Context&lt;WindowClassTag&gt;&amp; context)<br />{<br />  BOOL handled = FALSE;<br />  LRESULT result = 0;<br />  std::tie(handled, result) =<br />    generator&lt;WindowClassTag, Target&gt;::type(<br />        base&lt;WindowClassTag, Target&gt;(<br />            target, &amp;context)).dispatch();<br /><br />  if (!handled) {<br />    std::tie(handled, result) =<br />      optionalUnhandled(target, context);<br />  }<br /><br />  return std::make_pair(<br />      handled ? true : false, result);<br />}<br /></pre><p>dispatch looks simple, it constructs a type stitched together in the generator detail class and calls the dispatch method on the class instance then if that function specifies that the message was not handled it calls <code class="prettyprint lang-cpp">optionalUnhandled</code>. When the guts of the generator are exposed later that facade of simplicity will disintegrate. Until that time enjoy the appearance of simplicity. </p><pre class="prettyprint lang-cpp"><br />struct UnhandledTag {};<br /></pre><p>The tag is used to increase the flexibility of the window_message_error_contract trait function. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename WindowClassTag, typename Target&gt;<br />std::pair&lt;bool, LRESULT&gt; optionalUnhandled(<br />  Target target,<br />  const Context&lt;WindowClassTag&gt;&amp; context,<br />  decltype(<br />    cmn::instance_of&lt;Target&gt;::value-&gt;OnUnhandled(<br />      cmn::instance_of&lt;Context&lt;WindowClassTag&gt;&gt;::value)))<br />{<br />  LRESULT result = 0;<br />  window_message_error_contract(<br />    [&amp;] {<br />      result = target-&gt;OnUnhandled(context);<br />    },<br />    context,<br />    UnhandledTag(),<br />    WindowClassTag()<br />  );<br />  return std::make_pair(true, result);<br />}<br /></pre><p>This optionalUnhandled overload is only included in the overload set if the decltype parameter can resolve the OnUnhandled(context) function on the target. </p><p>The window_message_error_contract function that must be provided by the target implementor can have many overloads in multiple namespaces. The two tag parameters allow this function to be provided once for the whole class or individually for each message type. The purpose of the error contract is for targets that enable exceptions to provide an overload that handles the exceptions. </p><p>Finally, the OnUnhandled method on target is called. </p><pre class="prettyprint lang-cpp"><br />inline std::pair&lt;bool, LRESULT&gt; optionalUnhandled(...)<br />{<br />  return std::make_pair(false, 0);<br />}<br /></pre><p>If the first overload is not valid then this one is used to report that the message is still unhandled. </p><p>This introduced the optional method construct, this is the mechanism that is used to detect whether the target supports each potential message. In this case it detects wether the target is interested in the unhanded messages. Providing this function on the target allows the target to chain the message to another handler. </p><p>Next up is the generator.. </p>