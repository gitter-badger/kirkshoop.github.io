---
layout: post
title: template policies via ADL
date: '2011-10-04T10:00:00.000-07:00'
author: Kirk
tags:
- programming
modified_time: '2011-10-04T10:00:06.680-07:00'
blogger_id: tag:blogger.com,1999:blog-7018293688983612487.post-4878822122320960978
blogger_orig_url: http://kirkshoop.blogspot.com/2011/10/template-policies-via-adl.html
---

<p>I wrote a range library some years ago and then found a proposal to include a <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2068.html">range library</a> in the std library. </p><p>I liked the design and decided to implement the proposal. One of the coolest features of the proposal is how ADL and decltype are used to implement traits or policies. </p><p>Since that time I have continued to refine the use of ADL and decltype to produce policies with vastly improved flexibility, stability and usability then anything I have seen before. </p><p>For example (Note: for space reasons this code is incomplete and won't compile. A working version of unique_t called unique_resource is available <a href="https://github.com/kirkshoop/libraries">here</a>) if we start with an existing smart-pointer that has a policy trait for the type and the way to close the type: </p><pre class="prettyprint lang-cpp"><br />// policy based type<br />template&lt;typename T, typename Close&gt;<br />class unique_t_classic;<br /><br />// user code using that type<br />template&lt;typename T, typename Close&gt;<br />void function(unique_t_classic&lt;T, Close&gt;&amp; t);<br /></pre><p>Then at some future time we wish to add an index trait to enable operator[] usage: </p><pre class="prettyprint lang-cpp"><br />// new policy<br />template&lt;<br />  typename T, <br />  typename Close, <br />  typename Index=DefaultIndex&lt;T&gt;&gt;<br />class unique_t_classic;<br /></pre><p>Now all the code that was dependent on the original policy set will fail to compile.<br />Here is the way I would express this functionality today: </p><pre class="prettyprint lang-cpp"><br />template&lt;typename TypeTag&gt;<br />class unique_t;<br /><br />template&lt;typename Tag&gt;<br />void function(unique_t&lt;Tag&gt;&amp; t);<br /></pre><p>Now we can explore three different implementations of this with different policies without changing any of the above. The initial implementation might look like this. </p><pre class="prettyprint lang-cpp"><br />template&lt;typename TypeTag&gt;<br />class unique_t<br />{<br />public:<br />  // these functions are looked up via ADL<br />  // thus this will pick up the definition<br />  // of unique_t_invalid_value from whatever<br />  // namespace TypeTag is in, and since TypeTag<br />  // is not the actual type (in database terms<br />  // it is a dataless key to the traits) the<br />  // user controls which namespace the<br />  // traits are in<br />  typedef decltype(unique_t_invalid_value(TypeTag()))<br />  type;<br />  //...<br />  void reset() {<br />    if (t != unique_t_invalid_value(TypeTag())) {<br />      unique_t_reset(t, TypeTag());<br />      t = unique_t_invalid_value(TypeTag());<br />    }<br />  }<br />private:<br />  type t;<br />};<br /></pre><p>A user might write code like this: </p><pre class="prettyprint lang-cpp"><br />// Usability is provided by allowing simple<br />// and static definitions of specific <br />// template instantiations<br />namespace detail<br />{<br />namespace file<br />{<br />struct tag {};<br />HANDLE unique_t_invalid_value(tag &amp;&amp;)<br />{<br />  return INVALID_HANDLE_VALUE;<br />}<br />void unique_t_reset(HANDLE value, tag &amp;&amp;)<br />{<br />  make_winerror_if(!CloseHandle(value)).suppress();<br />}<br />}<br />}<br />typedef unique_t&lt;detail::file::tag&gt;<br />unique_file;<br /></pre><p>Now it is time to make some changes to unique.<br />This will add <strong>optional</strong> indexing capability: </p><pre class="prettyprint lang-cpp"><br />template&lt;typename TypeTag&gt;<br />class unique_t<br />{<br />public:<br />  ...<br />  auto operator[](<br />    size_t at) -&gt; decltype(<br />        unique_t_index(at, TypeTag())) {<br />    return unique_t_index(at, TypeTag());<br />  }<br />private:<br />  type t;<br />};<br /></pre><p>unique_file still works as before. It does not support operator[] because it does not define unique_t_index.<br />More dramatic changes can be made without breaking existing code. This will make the type trait <strong>optionally</strong> independent of the return value of unique_t_invalid_value: </p><pre class="prettyprint lang-cpp"><br />//<br />// This is a completely optional type<br />// it merely provides a succinct way <br />// to create a type with a typedef <br />// of the correct name <br />//<br />template&lt;typename T&gt;<br />struct unique_t_traits_builder {<br />  typedef T<br />  type;<br />};<br /><br />namespace detail<br />{<br />//<br />// this implements the optional part.<br />//<br />// notice that neither of these functions<br />// are implemented, they are only used in <br />// declspec so no implementation is referenced<br />//<br />// the users definition of unique_t_traits<br />// needs no implementation either.<br />//<br /><br />// this is used if the user supplied a <br />// unique_t_traits for the TypeTag<br />template&lt;typename TypeTag&gt;<br />auto resolve_unique_t_traits(<br />  size_t) -&gt; decltype(unique_t_traits(TypeTag()));<br /><br />// the is used if the user only supplied <br />// unique_t_invalid_value for the TypeTag<br />template&lt;typename TypeTag&gt;<br />unique_t_traits_builder&lt;unique_t_invalid_value(TypeTag())&gt;<br />resolve_unique_t_traits(...);<br />}<br /><br />template&lt;typename TypeTag&gt;<br />class unique_t<br />{<br />public:<br />  typedef decltype(<br />    detail::resolve_unique_t_traits(TypeTag()))<br />  traits;<br /><br />  typedef typename traits::type<br />  type;<br />  // ...<br />  void reset() {<br />    if (t != unique_t_invalid_value(TypeTag())) {<br />      unique_t_reset(t, TypeTag());<br />      t = unique_t_invalid_value(TypeTag());<br />    }<br />  }<br />private:<br />  type t;<br />};<br /></pre><p>Viola! no change to user code was required even though the implementation changed dramatically and the traits are different. This provides stability and flexibility that previous policy patterns lacked. </p> 